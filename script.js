// 타겟별 샘플 콘텐츠 생성 (네이버 SEO 최적화)
function generateTargetSpecificSampleContent(topic, targetName) {
    const seoTitle = `${topic.title} | ${targetName} 필수가이드 2024`;
    
    return `# ${seoTitle}

안녕하세요, **${targetName}** 여러분! 오늘은 **${topic.keywords[0]}**에 대해 현장에서 바로 활용할 수 있는 **전문적인 내용**을 상세히 공유하겠습니다.

${topic.keywords[0]}는 ${targetName}에게 매우 중요한 요소입니다. 특히 **${topic.keywords[1]}**와 연관하여 체계적으로 접근하면 더욱 효과적인 결과를 얻을 수 있습니다.

## ${topic.keywords[0]}의 핵심 이해

### 왜 ${topic.keywords[0]}가 중요한가?

**${targetName}**으로서 여러분이 일상적으로 마주치는 ${topic.keywords[0]} 관련 이슈들을 효과적으로 해결할 수 있는 방법들을 알아보겠습니다.

현장에서 **${topic.keywords[1]}**와 관련된 업무를 처리할 때, 체계적인 접근법이 없다면 시간과 비용이 낭비될 수 있습니다. 특히 ${targetName}에게는 다음과 같은 이유로 중요합니다:

- **효율성 향상**: 올바른 ${topic.keywords[0]} 적용으로 업무 처리 시간 30% 단축
- **품질 개선**: 전문적인 ${topic.keywords[2]} 활용으로 서비스 품질 향상
- **고객 만족**: 더 나은 결과로 고객 만족도 85% 이상 달성
- **수익성**: 효과적인 방법으로 월평균 수익성 15% 개선

## 실무 적용 가능한 구체적 방법론

### 1단계: ${topic.keywords[0]} 현상 파악 및 분석

**${topic.keywords[0]}**를 다룰 때 가장 먼저 해야 할 일은 정확한 현상 파악입니다. 실무에서 검증된 체크리스트를 활용해보세요.

**필수 체크리스트:**
- [ ] 기본 상황 및 조건 확인
- [ ] 관련 요소들 종합 분석  
- [ ] 명확한 목표 설정 및 우선순위 결정
- [ ] 필요 자원 및 도구 파악
- [ ] 예상 소요 시간 및 비용 산정

### 2단계: 전문적 접근법 적용

**${targetName}**의 전문성을 활용한 체계적 접근 방식입니다:

**이론적 기반 마련**
- ${topic.keywords[0]}의 핵심 원리와 작동 메커니즘 이해
- 업계 표준 및 베스트 프랙티스 철저 검토
- 최신 연구 결과 및 트렌드 분석

**실무 기술 적용**
- 현장에서 검증된 **${topic.keywords[1]}** 기법 활용
- 개인별/상황별 맞춤 조정 방법
- 효과 측정 및 개선 방안

**결과 모니터링 및 최적화**
- 단계별 진행 상황 체크
- 실시간 피드백 수집 및 분석
- 필요시 즉시 조정 및 보완

### 3단계: 고급 테크닉과 실전 노하우

경험 많은 **${targetName}**들이 실제로 사용하는 고급 기법들을 공개합니다:

**전문가 핵심 팁 #1**: ${topic.keywords[2]} 최대 활용법
- 구체적인 적용 방법과 단계별 가이드
- 주의해야 할 핵심 포인트 5가지
- 다양한 상황별 응용 방법

**전문가 핵심 팁 #2**: 효율성 극대화 전략
- 시간 절약을 위한 핵심 테크닉
- 품질 향상을 위한 체크포인트
- 비용 효율적 접근법과 리소스 관리

**전문가 핵심 팁 #3**: 문제 해결 시나리오
- 일반적인 문제 상황별 대응법
- 응급 상황 시 빠른 해결 방법
- 예방을 위한 사전 관리 시스템

## ${targetName}을 위한 실제 현장 사례

### 사례 1: 일반적인 상황에서의 ${topic.keywords[0]} 적용

"실제로 저희 현장에서 **${topic.keywords[0]}**를 적용할 때 가장 효과적이었던 방법은..."

**상황**: 전형적인 업무 환경에서의 적용 사례
**적용 방법**: 단계별 구체적 실행 과정
**결과**: 30일 후 측정된 정량적 성과
**핵심 포인트**: 성공 요인 3가지 분석

### 사례 2: 까다로운 상황에서의 문제 해결

"특별히 어려운 케이스의 경우, **${topic.keywords[1]}** 접근법이 매우 유용했습니다..."

**도전 과제**: 복잡하고 까다로운 상황 설명
**해결 과정**: 창의적 문제 해결 접근법
**교훈**: 향후 유사 상황 대비 노하우

### 사례 3: 혁신적 적용으로 성과 극대화

"창의적으로 접근했던 이 성공 사례는 업계에서도 주목받았습니다..."

**혁신 포인트**: 기존 방식과 차별화된 접근
**실행 과정**: 단계별 실행 전략
**성과**: 예상보다 200% 향상된 결과

## 자주 묻는 질문 (FAQ)

### Q1: ${topic.keywords[0]} 적용 시 가장 흔한 실수는?

**A**: 가장 흔한 실수는 **기본기를 무시하고 고급 기법만 추구하는 것**입니다. ${topic.keywords[0]}의 기초 원리를 충분히 이해하지 못한 상태에서 복잡한 방법을 적용하면 오히려 역효과가 날 수 있습니다.

**예방법**:
- 기초 이론 충분히 학습
- 단계별 점진적 적용
- 정기적인 기본기 점검

### Q2: ${targetName} 초보자도 바로 적용 가능한가요?

**A**: 네, 충분히 가능합니다. 다만 **단계별 접근**이 중요합니다. 처음에는 기본적인 ${topic.keywords[1]} 방법부터 시작하여 점차 고급 기법으로 발전시켜 나가세요.

**초보자 추천 순서**:
- 1단계: 기본 이론 학습 (1-2주)
- 2단계: 간단한 실습 (2-3주)  
- 3단계: 응용 및 심화 (4주 이후)

### Q3: 얼마나 자주 ${topic.keywords[0]}를 적용해야 하나요?

**A**: **일관성**이 가장 중요합니다. 매일 조금씩이라도 꾸준히 적용하는 것이 일주일에 한 번 많이 하는 것보다 효과적입니다.

**권장 빈도**:
- 초기 단계: 주 2-3회 (학습 기간)
- 중급 단계: 주 4-5회 (숙련 기간)
- 고급 단계: 매일 (유지 및 발전)

## 주의사항과 전문가 특별 조언

### 반드시 피해야 할 실수들

**1. 과도한 적용**
- 무리한 시도는 오히려 역효과 초래
- 개인의 역량과 상황을 고려한 적절한 수준 유지
- 점진적 발전이 지속가능한 성장의 열쇠

**2. 기본 원리 무시**
- 기초를 건너뛰고 고급 기법만 추구하는 실수
- **${topic.keywords[0]}**의 핵심 원리 충분한 이해 필요
- 기본기가 탄탄해야 응용도 자유롭게 가능

**3. 획일적 적용**
- 상황별 맞춤 없이 동일한 방법만 반복 사용
- 개인차와 환경적 요인 고려 필수
- 유연한 사고와 적응력이 성공의 핵심

### 성공을 위한 핵심 성공 요소

**지속적 학습과 업데이트**
- 새로운 기법과 트렌드 지속적 습득
- 동료 전문가들과의 정보 교환
- 정기적인 교육 및 세미나 참석

**실전 경험 축적**
- 다양한 케이스 직접 경험하기
- 실패를 통한 학습과 개선
- 성공 사례 체계적 기록 및 분석

**네트워킹과 협업**
- 동료 **${targetName}**들과의 활발한 교류
- 온라인 커뮤니티 적극 참여
- 멘토 및 선배와의 정기적 상담

## 도구와 리소스 완벽 활용법

### 필수 준비 사항

**기본 도구 및 장비**
- **필수 도구**: 반드시 갖춰야 할 핵심 장비 5가지
- **보조 도구**: 효율성 향상을 위한 추가 도구들
- **디지털 도구**: 최신 앱 및 소프트웨어 활용법

**지식 및 정보 자원**
- 전문 서적 및 연구 자료
- 온라인 강의 및 튜토리얼
- 업계 전문지 및 뉴스레터

### 추천 학습 리소스

**온라인 교육 과정**
- **${targetName}** 전용 인증 과정
- 해외 유명 기관의 온라인 강의
- 실무 중심의 현장 교육 프로그램

**커뮤니티 및 네트워크**
- 국내 최대 **${targetName}** 온라인 카페
- 해외 전문가 포럼 및 그룹
- 지역별 오프라인 모임 정보

## 단계별 실행 계획 및 로드맵

### 즉시 실행 가능한 액션 플랜

**이번 주 내 실행 목표**
- [ ] 기본 체크리스트 작성 및 현황 파악
- [ ] **${topic.keywords[0]}** 관련 도구 및 자료 정리
- [ ] 첫 번째 실습 계획 수립

**이번 달 내 달성 목표**
- [ ] 핵심 기법 2-3가지 현장 적용
- [ ] 동료와의 경험 공유 및 피드백 수집
- [ ] 초기 결과 측정 및 분석

**3개월 내 중기 목표**
- [ ] 전체 시스템 완전 정착
- [ ] 개인 맞춤 방법론 확립
- [ ] 정량적 성과 측정 및 개선점 도출

### 장기 발전 계획

**6개월 목표**: 숙련도 향상 및 응용 범위 확대
- 고급 기법 마스터
- 창의적 응용 방법 개발
- 후배 지도 및 멘토링 시작

**1년 목표**: 해당 분야 인정받는 전문가 되기
- 업계 내 전문가로 인정
- 강의 및 컨설팅 기회 확보
- 개인 브랜드 구축 및 네트워크 확장

**지속적 목표**: 최신 트렌드 반영 및 지속적 개선
- 최신 기술 및 트렌드 지속 학습
- 개인 노하우 지속적 업데이트
- 업계 발전에 기여하는 활동

## 마무리: ${targetName}을 위한 특별한 조언

**${topic.keywords[0]}**에 대한 이해와 적용은 **${targetName}**에게 경쟁력을 제공하는 핵심 역량입니다. 

오늘 소개한 방법들을 현장에서 단계적으로 적용해보시고, 여러분만의 노하우로 발전시켜 나가시기 바랍니다.

**중요한 것은 꾸준함입니다.** 전문가는 하루아침에 만들어지지 않습니다. 지속적인 학습과 실습을 통해 더욱 발전된 **${targetName}**이 되어가시길 응원합니다.

**${topic.keywords[1]}**와 **${topic.keywords[2]}**를 조합한 여러분만의 창의적인 방법을 개발해보세요. 그것이 바로 진정한 전문가로 성장하는 지름길입니다.

---

💬 **여러분의 ${topic.keywords[0]} 경험을 댓글로 공유해주세요!** 어떤 방법이 가장 효과적이었는지, 또는 어려웠던 점은 무엇인지 궁금합니다.

👍 **이 글이 도움이 되셨다면 좋아요와 공유 부탁드립니다!** 더 많은 **${targetName}**들에게 유용한 정보가 전달될 수 있도록 함께해주세요.

🔔 **정기적인 전문 정보를 받아보시려면 구독해주세요!** 매주 실무에 도움되는 최신 정보와 노하우를 공유하겠습니다.

📞 **개별 상담이나 문의사항이 있으시면 언제든 연락주세요!** ${targetName} 전문 컨설팅도 제공하고 있습니다.

---

**💼 ${targetName} 전용 추가 리소스**
- 📚 관련 전문 교육 과정 정보 및 할인 혜택
- 📈 업계 동향 및 최신 트렌드 분석 레포트
- 🤝 전문가 네트워크 참여 방법 및 모임 일정
- 🛠️ 실무 도구 및 장비 추천 리스트

*본 글은 현장 경험이 풍부한 **${targetName}**들의 실무 노하우와 최신 연구 결과를 바탕으로 작성되었습니다. 모든 내용은 실제 적용 가능하며, 지속적으로 업데이트하여 최신 정보를 제공합니다.*`;
}// HAIRGATOR 완전한 블로그 자동화 시스템 - JavaScript

// 타겟 독자별 전문 분야 및 주제 데이터
const targetAudienceData = {
    hair_professionals: {
        name: "헤어 디자이너 & 헤어 관련 종사자",
        description: "헤어 전문가들을 위한 실무 중심 콘텐츠를 작성합니다.",
        features: [
            "최신 헤어 트렌드 및 기법",
            "고객 상담 및 서비스 노하우", 
            "살롱 운영 및 마케팅 팁",
            "제품 지식 및 기술 정보"
        ],
        categories: {
            techniques: "헤어 기법 & 테크닉",
            trends: "트렌드 & 스타일",
            business: "살롱 운영 & 비즈니스",
            products: "제품 & 도구"
        },
        topics: {
            techniques: [
                {
                    id: 1,
                    title: "2024 트렌드 컷 기법: 레이어드 볼륨 컷 마스터하기",
                    keywords: ["레이어드컷", "볼륨컷", "헤어기법", "커팅테크닉", "트렌드컷"],
                    targetLevel: "intermediate"
                },
                {
                    id: 2, 
                    title: "문제 모발 고객 대응법: 손상모발 복구 시술 가이드",
                    keywords: ["손상모발", "복구시술", "고객상담", "문제해결", "헤어케어"],
                    targetLevel: "expert"
                }
            ],
            trends: [
                {
                    id: 3,
                    title: "2024 F/W 헤어컬러 트렌드: 고객에게 제안할 베스트 컬러",
                    keywords: ["헤어컬러", "트렌드컬러", "고객제안", "컬러링", "시즌트렌드"],
                    targetLevel: "intermediate"
                }
            ],
            business: [
                {
                    id: 4,
                    title: "헤어샵 매출 증대 전략: 단골 고객 만들기 7가지 방법",
                    keywords: ["살롱운영", "매출증대", "고객관리", "마케팅", "단골고객"],
                    targetLevel: "expert"
                }
            ],
            products: [
                {
                    id: 5,
                    title: "프로용 헤어도구 완벽 가이드: 가위부터 드라이어까지",
                    keywords: ["헤어도구", "프로용기기", "도구선택", "장비관리", "투자가이드"],
                    targetLevel: "beginner"
                }
            ]
        },
        expertTerms: ["커팅", "레이어링", "그라데이션", "텍스처라이징", "포인트컷", "슬라이스", "섹션", "가이드라인", "오버다이렉션"],
        writingStyle: {
            tone: "전문적이면서 실무 중심적",
            approach: "기술적 디테일과 실전 노하우 강조",
            structure: "이론 → 실습 → 응용 → 고객 적용"
        }
    },
    
    beauty_professionals: {
        name: "뷰티 전문가 & 미용사", 
        description: "뷰티 전문가들을 위한 종합 미용 정보를 제공합니다.",
        features: [
            "최신 뷰티 트렌드 분석",
            "고객별 맞춤 서비스",
            "샵 운영 노하우",
            "제품 및 기술 정보"
        ],
        categories: {
            skincare: "스킨케어 & 관리",
            makeup: "메이크업 & 컬러",
            nails: "네일 & 아트",
            business: "샵 운영 & 마케팅"
        }
    },
    
    fitness_trainers: {
        name: "퍼스널 트레이너 & 피트니스 전문가",
        description: "피트니스 전문가들을 위한 운동 및 트레이닝 정보를 제공합니다.",
        features: [
            "운동 프로그램 설계",
            "고객 맞춤 트레이닝",
            "영양 및 컨디셔닝", 
            "PT샵 운영 노하우"
        ],
        categories: {
            training: "트레이닝 & 운동법",
            nutrition: "영양 & 식단",
            rehabilitation: "재활 & 교정",
            business: "PT샵 운영"
        }
    },
    
    chefs_cooks: {
        name: "셰프 & 요리사",
        description: "요리 전문가들을 위한 조리 기법 및 레시피 정보를 제공합니다.",
        features: [
            "전문 조리 기법",
            "메뉴 개발 및 기획",
            "식재료 관리법",
            "주방 운영 시스템"
        ],
        categories: {
            techniques: "조리 기법 & 스킬",
            menu: "메뉴 개발 & 기획", 
            ingredients: "식재료 & 관리",
            kitchen: "주방 운영 & 관리"
        }
    },
    
    it_developers: {
        name: "개발자 & IT 전문가",
        description: "개발자들을 위한 기술 및 개발 정보를 제공합니다.",
        features: [
            "최신 개발 기술 트렌드",
            "코딩 베스트 프랙티스",
            "프로젝트 관리 노하우",
            "커리어 개발 가이드"
        ],
        categories: {
            frontend: "프론트엔드 개발",
            backend: "백엔드 개발",
            devops: "데브옵스 & 인프라",
            career: "커리어 & 성장"
        }
    }
};

// 현재 선택된 타겟 독자
let currentTargetAudience = 'hair_professionals';

// 타겟 독자 설정 초기화
function initializeTargetAudience() {
    const targetSelect = document.getElementById('primaryTarget');
    const customTargetDiv = document.getElementById('customTarget');
    const targetDescription = document.getElementById('targetDescription');
    
    if (targetSelect) {
        targetSelect.addEventListener('change', function() {
            const selectedTarget = this.value;
            
            if (selectedTarget === 'custom') {
                customTargetDiv.style.display = 'block';
                targetDescription.innerHTML = `
                    <p><strong>사용자 정의 타겟</strong>을 위한 맞춤형 콘텐츠를 작성합니다.</p>
                    <p class="custom-note">구체적인 직업이나 분야를 입력해주세요 (예: 카페 사장들, 펜션 운영자들)</p>
                `;
            } else {
                customTargetDiv.style.display = 'none';
                updateTargetDescription(selectedTarget);
                currentTargetAudience = selectedTarget;
                loadTopicsForTarget(selectedTarget);
            }
        });
    }
    
    // 초기 설정
    updateTargetDescription(currentTargetAudience);
    loadTopicsForTarget(currentTargetAudience);
}

// 타겟 설명 업데이트
function updateTargetDescription(targetKey) {
    const targetDescription = document.getElementById('targetDescription');
    const targetData = targetAudienceData[targetKey];
    
    if (targetData && targetDescription) {
        const featuresHTML = targetData.features.map(feature => `<li>• ${feature}</li>`).join('');
        
        targetDescription.innerHTML = `
            <p><strong>${targetData.name}</strong>를 위한 전문 콘텐츠를 작성합니다.</p>
            <ul>${featuresHTML}</ul>
        `;
    }
}

// 타겟별 주제 로드
function loadTopicsForTarget(targetKey) {
    const targetData = targetAudienceData[targetKey];
    if (!targetData || !targetData.topics) {
        // 기존 헤어케어 주제 사용 (fallback)
        loadTopics();
        return;
    }
    
    // 타겟별 주제로 전역 변수 업데이트
    Object.assign(haircareTopics, targetData.topics);
    
    // 카테고리 탭 업데이트
    updateCategoryTabs(targetData.categories);
    
    // 주제 목록 새로고침
    loadTopics();
}

// 카테고리 탭 업데이트
function updateCategoryTabs(categories) {
    const categoryTabsContainer = document.querySelector('.category-tabs');
    if (!categoryTabsContainer || !categories) return;
    
    categoryTabsContainer.innerHTML = `
        <button class="tab-btn active" data-category="all">전체</button>
        ${Object.entries(categories).map(([key, name]) => 
            `<button class="tab-btn" data-category="${key}">${name}</button>`
        ).join('')}
    `;
    
    // 이벤트 리스너 재설정
    setupCategoryTabs();
}

// 네이버 상위노출 최적화 프롬프트 생성
function createNaverOptimizedPrompt(topic) {
    const targetData = targetAudienceData[currentTargetAudience];
    const targetName = targetData ? targetData.name : '전문가들';
    
    return `당신은 네이버 블로그 상위노출 전문가이며 ${targetName}을 위한 콘텐츠 작성자입니다.

【네이버 SEO 최적화 필수 요구사항】

1. 제목 최적화:
- 핵심 키워드 "${topic.keywords[0]}" 반드시 포함
- 30-60자 길이 (네이버 검색결과 노출 최적화)
- 클릭을 유도하는 흥미로운 표현 사용
- 예: "${topic.keywords[0]} 완전정복", "${topic.keywords[0]} 실전가이드"

2. 본문 구조 (네이버 알고리즘 선호):
- 첫 문단에 핵심 키워드 자연스럽게 2-3회 포함
- H2 소제목 3-5개 (## 사용), 각 소제목에 키워드 포함
- H3 세부 소제목 2-3개 (### 사용)
- 목록 형태(-) 적극 활용 (최소 5개 이상)
- **굵은 글씨** 강조 구문 5개 이상 사용
- 적절한 단락 나누기 (한 단락 3-4줄)

3. 키워드 최적화:
- 핵심 키워드: ${topic.keywords.join(', ')}
- 키워드 밀도: 전체 글의 2-3% (자연스럽게)
- 제목, 첫문단, 소제목, 마지막문단에 키워드 배치
- 연관 키워드와 동의어 적극 활용

4. 사용자 참여 유도 (네이버 알고리즘 가점):
- 댓글 유도 문구 3개 이상 포함
- "댓글로 경험을 공유해주세요"
- "좋아요와 공유 부탁드립니다"
- 질문형 문장으로 독자 참여 유도

5. 전문성 및 신뢰성:
- ${targetName}의 실무 경험담 포함
- 구체적인 수치와 데이터 제시
- 전문 용어 사용 후 쉬운 설명 병행
- 단계별 실행 방법 상세 제공

6. 콘텐츠 길이:
- 최소 2000자 이상 (네이버 선호 길이)
- 정보 밀도 높은 알찬 내용
- 실무에 바로 적용 가능한 구체적 방법

【글 구조 템플릿】
# [키워드 포함 SEO 제목]

## 서론 (첫 문단에 키워드 2-3회)
${targetName}들이 ${topic.keywords[0]}에 대해 알아야 할 핵심 내용...

## ${topic.keywords[0]}의 기본 이해 
### 핵심 개념
### 중요성

## 실무 적용 방법
### 1단계: [구체적 방법]
### 2단계: [상세 설명]
### 3단계: [실전 팁]

## ${targetName}을 위한 전문 노하우
- 실무 경험담
- 주의사항
- 효과적인 활용법

## 자주 묻는 질문 (FAQ)
### Q1: [실제 궁금한 점]
### Q2: [현실적 문제]

## 마무리 및 실행 계획
[키워드 재언급, CTA 포함]

---
💬 여러분의 ${topic.keywords[0]} 경험을 댓글로 공유해주세요!
👍 도움이 되셨다면 좋아요와 공유 부탁드립니다!

작성 시 반드시 지켜야 할 사항:
- 자연스러운 키워드 배치 (스팸성 키워드 반복 금지)
- 읽기 쉬운 문체와 적절한 존댓말 사용
- 실제 도움이 되는 유용한 정보 제공
- 원본성 확보 (표절이나 복사 금지)
- 정확한 정보와 최신 트렌드 반영

주제: ${topic.title}
타겟: ${targetName}
키워드: ${topic.keywords.join(', ')}
목표: 네이버 블로그 상위 노출 + 높은 사용자 만족도`;
}

// 기존 generateHaircareContent 함수 수정
async function generateTargetSpecificContent(topic) {
    return new Promise((resolve) => {
        setTimeout(() => {
            const targetData = targetAudienceData[currentTargetAudience];
            const targetName = targetData ? targetData.name : '전문가들';
            
            // 타겟별 맞춤 샘플 콘텐츠 생성
            const content = {
                title: `${topic.title} | ${targetName} 전용 가이드`,
                content: generateTargetSpecificSampleContent(topic, targetName),
                metaDescription: `${topic.title}에 대한 ${targetName}을 위한 전문 가이드입니다.`
            };
            
            resolve(content);
        }, 3000);
    });
}

// 타겟별 샘플 콘텐츠 생성
function generateTargetSpecificSampleContent(topic, targetName) {
    const targetData = targetAudienceData[currentTargetAudience];
    
    return `# ${topic.title}

안녕하세요, ${targetName} 여러분! 오늘은 ${topic.keywords[0]}에 대해 현장에서 바로 활용할 수 있는 전문적인 내용을 공유하겠습니다.

## 현장 전문가 관점에서 보는 ${topic.keywords[0]}

${targetName}으로서 여러분이 일상적으로 마주치는 ${topic.keywords[0]} 관련 이슈들을 효과적으로 해결할 수 있는 방법들을 알아보겠습니다.

### 왜 이것이 중요한가?

현장에서 ${topic.keywords[1]}와 관련된 업무를 처리할 때, 체계적인 접근법이 없다면 시간과 비용이 낭비될 수 있습니다. 특히 ${targetName}에게는 다음과 같은 이유로 중요합니다:

- **효율성 향상**: 올바른 방법으로 업무 처리 시간 단축
- **품질 개선**: 전문적인 서비스 품질 향상
- **고객 만족**: 더 나은 결과로 고객 만족도 증대
- **수익성**: 효과적인 방법으로 수익성 개선

## 실무 적용 가능한 구체적 방법론

### 1단계: 현상 파악 및 분석
${topic.keywords[0]}를 다룰 때 가장 먼저 해야 할 일은 정확한 현상 파악입니다.

**체크리스트:**
- [ ] 기본 상황 확인
- [ ] 관련 요소들 분석  
- [ ] 목표 설정
- [ ] 필요 자원 파악

### 2단계: 전문적 접근법 적용
${targetName}의 전문성을 활용한 체계적 접근:

1. **이론적 기반 마련**
   - 관련 원리와 메커니즘 이해
   - 업계 표준 및 베스트 프랙티스 검토

2. **실무 기술 적용**
   - 현장에서 검증된 기법 활용
   - 개인별/상황별 맞춤 조정

3. **결과 모니터링**
   - 진행 상황 체크
   - 필요시 조정 및 보완

### 3단계: 고급 테크닉과 노하우

경험 많은 ${targetName}들이 사용하는 고급 기법들:

**전문가 팁 #1**: ${topic.keywords[2]} 활용법
- 구체적인 적용 방법
- 주의해야 할 포인트
- 응용 가능한 상황들

**전문가 팁 #2**: 효율성 극대화 방법
- 시간 절약 테크닉
- 품질 향상 포인트
- 비용 효율적 접근법

## 실제 현장 사례와 경험담

### 사례 1: 일반적인 상황 대응
"실제로 저희 현장에서 ${topic.keywords[0]}를 적용할 때..."

### 사례 2: 까다로운 상황 해결
"특별히 어려운 케이스의 경우..."

### 사례 3: 혁신적 적용 사례
"창의적으로 접근했던 성공 사례..."

## 주의사항과 전문가 조언

### 피해야 할 실수들
1. **과도한 적용**: 무리한 시도는 역효과
2. **기본 무시**: 기초를 건너뛰고 고급 기법만 추구
3. **일괄 적용**: 상황별 맞춤 없이 동일하게 적용

### 성공을 위한 핵심 포인트
- **지속적 학습**: 새로운 기법과 트렌드 습득
- **경험 축적**: 다양한 케이스 경험하기
- **네트워킹**: 동료 전문가들과의 정보 교환
- **고객 중심**: 항상 최종 사용자/고객 관점에서 접근

## 도구와 리소스 활용법

### 필수 도구들
- **기본 도구**: 반드시 갖춰야 할 장비/소프트웨어
- **고급 도구**: 전문성 향상을 위한 추가 도구
- **관리 도구**: 효율적 업무 관리를 위한 시스템

### 추천 리소스
- 전문 교육 과정
- 업계 간행물 및 매체
- 온라인 커뮤니티 및 포럼
- 전문가 네트워크

## 실행 계획과 다음 단계

### 즉시 실행 가능한 액션 플랜
1. **이번 주 내**: 기본 체크리스트 작성 및 현황 파악
2. **이번 달 내**: 핵심 기법 1-2가지 현장 적용
3. **3개월 내**: 전체 시스템 정착 및 효과 측정

### 장기 발전 계획
- **6개월 목표**: 숙련도 향상 및 응용 범위 확대
- **1년 목표**: 해당 분야 전문가로 인정받기
- **지속적**: 최신 트렌드 반영 및 지속적 개선

## 마무리: ${targetName}을 위한 특별 조언

${topic.keywords[0]}에 대한 이해와 적용은 ${targetName}에게 경쟁력을 제공하는 핵심 역량입니다. 

오늘 소개한 방법들을 현장에서 단계적으로 적용해보시고, 여러분만의 노하우로 발전시켜 나가시기 바랍니다.

**기억하세요**: 전문가는 하루아침에 만들어지지 않습니다. 꾸준한 학습과 실습을 통해 더욱 발전된 ${targetName}이 되어가시길 응원합니다.

---

💼 **${targetName} 전용 추가 리소스**
- 관련 전문 교육 과정 정보
- 업계 동향 및 트렌드 분석
- 전문가 네트워크 참여 방법

*본 글은 현장 경험이 풍부한 ${targetName}들의 실무 노하우를 바탕으로 작성되었습니다.*`;
}
let generatedContent = null;
let qualityData = null;
let automationEnabled = false;
let systemStats = {
    totalPosts: 0,
    publishedPosts: 0,
    qualityScore: 0,
    systemStatus: '가동중'
};

// 헤어케어 전문 주제 데이터
const haircareTopics = {
    basic: [
        {
            id: 1,
            title: "모발 타입별 맞춤 샴푸 선택법",
            keywords: ["샴푸", "모발타입", "헤어케어", "건성모발", "지성모발"],
            category: "basic",
            targetAudience: "헤어케어 초보자",
            difficulty: "beginner"
        },
        {
            id: 2,
            title: "올바른 헤어 드라이 방법과 주의사항",
            keywords: ["헤어드라이어", "모발건조", "헤어케어", "모발손상예방"],
            category: "basic",
            targetAudience: "일반인",
            difficulty: "beginner"
        },
        {
            id: 3,
            title: "트리트먼트 vs 헤어팩 완벽 비교",
            keywords: ["트리트먼트", "헤어팩", "모발영양", "헤어케어제품"],
            category: "basic",
            targetAudience: "헤어케어 관심층",
            difficulty: "intermediate"
        }
    ],
    styling: [
        {
            id: 4,
            title: "2024년 최신 헤어 트렌드 완벽 가이드",
            keywords: ["헤어트렌드", "헤어스타일", "2024트렌드", "유행헤어"],
            category: "styling",
            targetAudience: "트렌드 팔로워",
            difficulty: "intermediate"
        },
        {
            id: 5,
            title: "얼굴형별 어울리는 헤어스타일 찾기",
            keywords: ["얼굴형", "헤어스타일", "헤어컨설팅", "스타일링"],
            category: "styling",
            targetAudience: "스타일링 고민층",
            difficulty: "intermediate"
        },
        {
            id: 6,
            title: "집에서 하는 간단한 헤어 어레인지 5가지",
            keywords: ["헤어어레인지", "셀프스타일링", "홈케어", "간편스타일링"],
            category: "styling",
            targetAudience: "바쁜 직장인",
            difficulty: "beginner"
        }
    ],
    treatment: [
        {
            id: 7,
            title: "탈모 예방과 효과적인 관리법",
            keywords: ["탈모예방", "모발관리", "두피케어", "헤어로스"],
            category: "treatment",
            targetAudience: "탈모 고민층",
            difficulty: "expert"
        },
        {
            id: 8,
            title: "손상모발 복구를 위한 집중 케어",
            keywords: ["손상모발", "모발복구", "헤어케어", "모발재생"],
            category: "treatment",
            targetAudience: "손상모발 고민층",
            difficulty: "intermediate"
        },
        {
            id: 9,
            title: "비듬과 두피 트러블 완벽 해결법",
            keywords: ["비듬", "두피트러블", "두피케어", "스칼프케어"],
            category: "treatment",
            targetAudience: "두피 고민층",
            difficulty: "intermediate"
        }
    ],
    trend: [
        {
            id: 10,
            title: "K-뷰티 헤어케어 글로벌 트렌드",
            keywords: ["K뷰티", "헤어케어트렌드", "한국뷰티", "글로벌트렌드"],
            category: "trend",
            targetAudience: "트렌드 선도층",
            difficulty: "expert"
        },
        {
            id: 11,
            title: "셀럽들의 헤어케어 비밀 레시피",
            keywords: ["셀럽헤어", "스타헤어케어", "헤어시크릿", "뷰티팁"],
            category: "trend",
            targetAudience: "셀럽 스타일 선호층",
            difficulty: "intermediate"
        },
        {
            id: 12,
            title: "계절별 헤어케어 필수 포인트",
            keywords: ["계절별헤어케어", "시즌케어", "헤어관리", "계절헤어"],
            category: "trend",
            targetAudience: "체계적 관리층",
            difficulty: "intermediate"
        }
    ]
};

// AI 설정 및 상태
const aiConfig = {
    claude: {
        connected: false,
        apiKey: null,
        lastTest: null
    },
    openai: {
        connected: false,
        apiKey: null,
        lastTest: null
    }
};

// 네이버 SEO 최적화를 위한 품질 기준 (업데이트됨)
const seoQualityStandards = {
    wordCount: { min: 1500, ideal: 2500, max: 5000 }, // 네이버 선호 길이
    keywordDensity: { min: 1.5, ideal: 2.5, max: 4.0 },
    titleLength: { min: 30, ideal: 50, max: 60 },
    metaLength: { min: 120, ideal: 140, max: 150 },
    headingCount: { min: 3, ideal: 5, max: 10 },
    engagement: { min: 1, ideal: 3, max: 5 } // CTA, 댓글유도 등
};

// 네이버 상위노출 키워드 패턴
const naverSEOPatterns = {
    titlePatterns: [
        "완전정복", "총정리", "핵심가이드", "실전팁", "비법공개", 
        "상세가이드", "완벽분석", "전문가추천", "베스트", "최신트렌드"
    ],
    engagementWords: [
        "댓글", "공유", "좋아요", "구독", "팔로우", "클릭", 
        "문의", "상담", "예약", "신청"
    ],
    trustSignals: [
        "전문가", "검증된", "인증", "추천", "후기", "리뷰", 
        "경험담", "실제", "진짜", "정말"
    ]
};

// 초기화 함수
document.addEventListener('DOMContentLoaded', function() {
    console.log('HAIRGATOR 시스템 초기화 시작...');
    
    // 초기 데이터 로드
    initializeSystem();
    loadTopics();
    setupEventListeners();
    startMonitoring();
    
    console.log('HAIRGATOR 시스템 초기화 완료!');
    showNotification('success', '시스템 초기화 완료', 'HAIRGATOR 블로그 자동화 시스템이 준비되었습니다.');
});

// 시스템 초기화
function initializeSystem() {
    // 타겟 독자 설정 초기화
    initializeTargetAudience();
    
    // 통계 업데이트
    updateSystemStats();
    
    // 자동화 설정 로드
    loadAutomationSettings();
    
    // 활동 로그 초기화
    initializeActivityLog();
    
    // 에디터 탭 설정
    setupEditorTabs();
    
    // 카테고리 탭 설정
    setupCategoryTabs();
}

// 이벤트 리스너 설정
function setupEventListeners() {
    // AI 연결 테스트 버튼
    const testButtons = document.querySelectorAll('.test-btn');
    testButtons.forEach(btn => {
        btn.addEventListener('click', handleAITest);
    });
    
    // 주제 관리 버튼들
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('topic-item')) {
            selectTopic(e.target);
        }
        if (e.target.classList.contains('delete-btn')) {
            deleteTopic(e.target.closest('.topic-item'));
        }
        if (e.target.classList.contains('edit-btn')) {
            editTopic(e.target.closest('.topic-item'));
        }
    });
    
    // 콘텐츠 변경 감지 + 문자 카운터
    const contentTextarea = document.getElementById('postContent');
    const titleInput = document.getElementById('postTitle');
    const seoTitleInput = document.getElementById('seoTitle');
    const metaDescInput = document.getElementById('metaDescription');
    
    if (contentTextarea) {
        contentTextarea.addEventListener('input', debounce(updateQualityMetrics, 500));
    }
    
    if (titleInput) {
        titleInput.addEventListener('input', debounce(updateQualityMetrics, 500));
    }
    
    // 문자 수 카운터 설정
    if (seoTitleInput) {
        seoTitleInput.addEventListener('input', function() {
            updateCharCounter('seoTitle', 'seoTitleCounter', 60);
        });
    }
    
    if (metaDescInput) {
        metaDescInput.addEventListener('input', function() {
            updateCharCounter('metaDescription', 'metaDescCounter', 150);
        });
    }
    
    // 자동화 토글
    const automationToggle = document.getElementById('automationEnabled');
    if (automationToggle) {
        automationToggle.addEventListener('change', toggleAutomation);
    }
    
    // 모달 외부 클릭 시 닫기
    window.addEventListener('click', function(e) {
        if (e.target.classList.contains('modal')) {
            closeModal(e.target.id);
        }
    });
}

// AI 연결 테스트
async function testClaudeConnection() {
    const keyInput = document.getElementById('claudeKey');
    const statusElement = document.getElementById('claudeStatus');
    const testBtn = event.target;
    
    if (!keyInput.value.trim()) {
        showNotification('warning', 'API 키 필요', 'Claude API 키를 입력해주세요.');
        return;
    }
    
    testBtn.textContent = '테스트 중...';
    testBtn.disabled = true;
    
    try {
        // 실제 API 테스트 (현재는 시뮬레이션)
        await simulateAPITest('claude', keyInput.value);
        
        aiConfig.claude.connected = true;
        aiConfig.claude.apiKey = keyInput.value;
        aiConfig.claude.lastTest = new Date();
        
        statusElement.textContent = '연결됨';
        statusElement.style.color = 'var(--success-color)';
        
        updateAIStatus();
        showNotification('success', 'Claude 연결 성공', 'Claude API 연결이 성공적으로 완료되었습니다.');
        
    } catch (error) {
        aiConfig.claude.connected = false;
        statusElement.textContent = '연결 실패';
        statusElement.style.color = 'var(--error-color)';
        
        showNotification('error', 'Claude 연결 실패', error.message);
    }
    
    testBtn.textContent = '테스트';
    testBtn.disabled = false;
}

async function testOpenAIConnection() {
    const keyInput = document.getElementById('openaiKey');
    const statusElement = document.getElementById('openaiStatus');
    const testBtn = event.target;
    
    if (!keyInput.value.trim()) {
        showNotification('warning', 'API 키 필요', 'OpenAI API 키를 입력해주세요.');
        return;
    }
    
    testBtn.textContent = '테스트 중...';
    testBtn.disabled = true;
    
    try {
        // 실제 API 테스트 (현재는 시뮬레이션)
        await simulateAPITest('openai', keyInput.value);
        
        aiConfig.openai.connected = true;
        aiConfig.openai.apiKey = keyInput.value;
        aiConfig.openai.lastTest = new Date();
        
        statusElement.textContent = '연결됨';
        statusElement.style.color = 'var(--success-color)';
        
        updateAIStatus();
        showNotification('success', 'OpenAI 연결 성공', 'OpenAI API 연결이 성공적으로 완료되었습니다.');
        
    } catch (error) {
        aiConfig.openai.connected = false;
        statusElement.textContent = '연결 실패';
        statusElement.style.color = 'var(--error-color)';
        
        showNotification('error', 'OpenAI 연결 실패', error.message);
    }
    
    testBtn.textContent = '테스트';
    testBtn.disabled = false;
}

// API 테스트 시뮬레이션
async function simulateAPITest(service, apiKey) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            // 실제 구현에서는 여기서 실제 API 호출
            if (apiKey.length > 10) {
                resolve({ status: 'success', service: service });
            } else {
                reject(new Error('유효하지 않은 API 키입니다.'));
            }
        }, 1500);
    });
}

// 주제 로드
function loadTopics(category = 'all') {
    const topicList = document.getElementById('topicList');
    if (!topicList) return;
    
    topicList.innerHTML = '';
    
    let topics = [];
    if (category === 'all') {
        Object.values(haircareTopics).forEach(categoryTopics => {
            topics = topics.concat(categoryTopics);
        });
    } else {
        topics = haircareTopics[category] || [];
    }
    
    topics.forEach(topic => {
        const topicElement = createTopicElement(topic);
        topicList.appendChild(topicElement);
    });
    
    if (topics.length === 0) {
        topicList.innerHTML = '<p class="no-topics">해당 카테고리에 주제가 없습니다.</p>';
    }
}

// 주제 요소 생성
function createTopicElement(topic) {
    const div = document.createElement('div');
    div.className = 'topic-item';
    div.dataset.topicId = topic.id;
    div.dataset.category = topic.category;
    
    div.innerHTML = `
        <div class="topic-content">
            <div class="topic-title">${topic.title}</div>
            <div class="topic-meta">
                <span class="topic-category">${getCategoryDisplayName(topic.category)}</span> • 
                <span class="topic-audience">${topic.targetAudience}</span> • 
                <span class="topic-keywords">${topic.keywords.slice(0, 3).join(', ')}</span>
            </div>
        </div>
        <div class="topic-actions">
            <button class="edit-btn">수정</button>
            <button class="delete-btn">삭제</button>
        </div>
    `;
    
    return div;
}

// 카테고리 표시명 변환
function getCategoryDisplayName(category) {
    const displayNames = {
        basic: '기초 케어',
        styling: '스타일링',
        treatment: '트리트먼트',
        trend: '트렌드'
    };
    return displayNames[category] || category;
}

// 주제 선택
function selectTopic(topicElement) {
    // 기존 선택 해제
    document.querySelectorAll('.topic-item').forEach(item => {
        item.classList.remove('selected');
    });
    
    // 새 주제 선택
    topicElement.classList.add('selected');
    
    const topicId = parseInt(topicElement.dataset.topicId);
    const category = topicElement.dataset.category;
    
    // 주제 데이터 찾기
    let selectedTopic = null;
    Object.values(haircareTopics).forEach(categoryTopics => {
        const found = categoryTopics.find(topic => topic.id === topicId);
        if (found) selectedTopic = found;
    });
    
    if (selectedTopic) {
        currentTopic = selectedTopic;
        updateSelectedTopicDisplay();
        logActivity('주제 선택', `"${selectedTopic.title}" 주제가 선택되었습니다.`);
    }
}

// 선택된 주제 표시 업데이트
function updateSelectedTopicDisplay() {
    const selectedTopicElement = document.getElementById('selectedTopic');
    if (!selectedTopicElement || !currentTopic) return;
    
    selectedTopicElement.innerHTML = `
        <div class="topic-info">
            <h3>${currentTopic.title}</h3>
            <div class="topic-details">
                <span class="category-badge">${getCategoryDisplayName(currentTopic.category)}</span>
                <span class="audience-badge">${currentTopic.targetAudience}</span>
                <span class="difficulty-badge">${getDifficultyDisplayName(currentTopic.difficulty)}</span>
            </div>
            <div class="topic-keywords">
                <strong>키워드:</strong> ${currentTopic.keywords.join(', ')}
            </div>
        </div>
    `;
}

// 난이도 표시명 변환
function getDifficultyDisplayName(difficulty) {
    const displayNames = {
        beginner: '초급',
        intermediate: '중급',
        expert: '고급'
    };
    return displayNames[difficulty] || difficulty;
}

// 카테고리 탭 설정
function setupCategoryTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    
    tabButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            // 모든 탭 비활성화
            tabButtons.forEach(tab => tab.classList.remove('active'));
            
            // 클릭된 탭 활성화
            this.classList.add('active');
            
            // 주제 로드
            const category = this.dataset.category;
            loadTopics(category);
        });
    });
}

// 에디터 탭 설정
function setupEditorTabs() {
    const editorTabs = document.querySelectorAll('.editor-tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    editorTabs.forEach(tab => {
        tab.addEventListener('click', function() {
            // 모든 탭 비활성화
            editorTabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            
            // 클릭된 탭 활성화
            this.classList.add('active');
            
            // 해당 콘텐츠 표시
            const tabName = this.dataset.tab;
            const targetContent = document.getElementById(tabName + 'Tab');
            if (targetContent) {
                targetContent.classList.add('active');
            }
        });
    });
}

// AI 콘텐츠 생성
async function generateContent() {
    if (!currentTopic) {
        showNotification('warning', '주제 선택 필요', '먼저 주제를 선택해주세요.');
        return;
    }
    
    if (!aiConfig.claude.connected) {
        showNotification('warning', 'Claude 연결 필요', 'Claude API를 먼저 연결해주세요.');
        return;
    }
    
    // 진행 상태 표시
    showGenerationProgress();
    
    try {
        // 실제 구현에서는 실제 API 호출
        const content = await generateHaircareContent(currentTopic);
        
        // 생성된 콘텐츠 에디터에 적용
        const titleInput = document.getElementById('postTitle');
        const contentTextarea = document.getElementById('postContent');
        const categorySelect = document.getElementById('postCategory');
        const tagsInput = document.getElementById('postTags');
        const metaDescription = document.getElementById('metaDescription');
        
        if (titleInput) titleInput.value = content.title;
        if (contentTextarea) contentTextarea.value = content.content;
        if (categorySelect) categorySelect.value = currentTopic.category;
        if (tagsInput) tagsInput.value = currentTopic.keywords.join(', ');
        if (metaDescription) metaDescription.value = content.metaDescription;
        
        generatedContent = content;
        
        // 품질 검사 자동 실행
        await checkQuality();
        
        // 통계 업데이트
        systemStats.totalPosts++;
        updateSystemStats();
        
        hideGenerationProgress();
        logActivity('콘텐츠 생성', `"${content.title}" 글이 생성되었습니다.`);
        showNotification('success', '콘텐츠 생성 완료', '헤어케어 전문 글이 성공적으로 생성되었습니다.');
        
    } catch (error) {
        hideGenerationProgress();
        logActivity('생성 실패', `콘텐츠 생성 중 오류가 발생했습니다: ${error.message}`, 'error');
        showNotification('error', '생성 실패', error.message);
    }
}

// 헤어케어 콘텐츠 생성 (시뮬레이션)
async function generateHaircareContent(topic) {
    return new Promise((resolve) => {
        setTimeout(() => {
            const sampleContents = {
                1: {
                    title: `${topic.title}: 헤어게이터 전문가 완벽 가이드`,
                    content: `# ${topic.title}

안녕하세요, 헤어게이터입니다! 오늘은 ${topic.keywords[0]}에 대해 전문적이고 실용적인 정보를 공유해드리겠습니다.

## ${topic.keywords[0]}의 중요성

${topic.targetAudience}을 위한 ${topic.keywords[0]} 가이드입니다. 헤어게이터의 10년 노하우를 바탕으로 정확하고 신뢰할 수 있는 정보를 제공해드립니다.

### 1. 기본 이해하기

${topic.keywords[0]}는 헤어케어의 핵심 요소 중 하나입니다. 특히 ${topic.keywords[1]}와 밀접한 관련이 있어 주의 깊은 관리가 필요합니다.

**주요 특징:**
- 개인별 모발 상태에 따른 차이
- 계절별 관리 방법의 변화
- 전문가 권장 사항

### 2. 실전 적용 방법

헤어게이터에서 권장하는 단계별 방법을 소개합니다:

1. **1단계: 현재 상태 파악**
   - 모발 타입 분석
   - 두피 상태 확인
   - 개인별 특성 고려

2. **2단계: 적절한 제품 선택**
   - ${topic.keywords[2]} 중심의 제품군
   - 성분 확인 포인트
   - 헤어게이터 추천 제품

3. **3단계: 올바른 사용법**
   - 적정 사용량과 빈도
   - 효과적인 적용 방법
   - 주의사항 및 팁

### 3. 전문가 조언

헤어게이터 전문팀의 핵심 조언:

- **지속성이 핵심**: 꾸준한 관리가 가장 중요합니다
- **개인 맞춤**: 획일적인 방법보다는 개인에게 맞는 접근
- **전문가 상담**: 정기적인 전문가 상담을 통한 점검

### 4. 흔한 실수와 해결법

많은 분들이 하시는 실수들과 개선 방안:

- 과도한 사용으로 인한 부작용
- 제품 선택 시 주의사항
- 계절별 관리법 차이 무시

## 헤어게이터의 특별한 팁

10년간의 현장 경험을 바탕으로 한 특별한 노하우를 공유합니다:

1. **모닝 루틴 최적화**
2. **저녁 관리의 중요성**
3. **주간/월간 집중 케어**

## 마무리

${topic.keywords[0]}에 대한 올바른 이해와 실천이 건강하고 아름다운 모발을 만드는 첫걸음입니다. 

헤어게이터와 함께 여러분만의 완벽한 헤어케어 루틴을 만들어보세요. 추가 문의사항이 있으시면 언제든 헤어게이터 전문 상담팀에 연락해주세요.

---

*본 글은 헤어게이터 전문 연구팀의 검증을 거친 정보입니다.*`,
                    metaDescription: `${topic.title}에 대한 헤어게이터의 전문가 가이드. ${topic.keywords.slice(0, 3).join(', ')} 중심으로 실용적인 헤어케어 팁을 제공합니다.`
                }
            };
            
            const content = sampleContents[topic.id] || {
                title: `${topic.title}: 헤어게이터 전문가 가이드`,
                content: `# ${topic.title}\n\n헤어게이터의 전문적인 ${topic.keywords[0]} 가이드입니다.\n\n${topic.keywords.map(keyword => `## ${keyword}에 대해\n\n전문적인 내용을 여기에 작성합니다.\n`).join('\n')}`,
                metaDescription: `${topic.title}에 대한 헤어게이터의 전문 정보를 확인하세요.`
            };
            
            resolve(content);
        }, 3000);
    });
}

// 진행 상태 표시/숨김
function showGenerationProgress() {
    const progressElement = document.getElementById('generationProgress');
    if (progressElement) {
        progressElement.style.display = 'block';
    }
}

function hideGenerationProgress() {
    const progressElement = document.getElementById('generationProgress');
    if (progressElement) {
        progressElement.style.display = 'none';
    }
}

// 품질 검사 (네이버 SEO 적용)
async function checkQuality() {
    const title = document.getElementById('postTitle')?.value || '';
    const content = document.getElementById('postContent')?.value || '';
    
    if (!title || !content) {
        showNotification('warning', '내용 필요', '제목과 본문을 입력해주세요.');
        return;
    }
    
    const quality = analyzeNaverSEOQuality(title, content);
    qualityData = quality;
    
    updateNaverSEODisplay(quality);
    logActivity('네이버 SEO 검사', `품질 점수: ${quality.overall}/100, 최적화: ${quality.naverOptimized ? 'YES' : 'NO'}`);
    
    return quality;
}

// 네이버 SEO 최적화 콘텐츠 품질 분석
function analyzeNaverSEOQuality(title, content) {
    const analysis = {
        wordCount: analyzeWordCount(content),
        keywordPlacement: analyzeKeywordPlacement(title, content),
        structureOptimization: analyzeNaverStructure(content),
        expertiseScore: analyzeExpertise(content),
        engagementScore: analyzeEngagement(content),
        overall: 0,
        naverOptimized: false
    };
    
    // 네이버 SEO 종합 점수 계산
    analysis.overall = Math.round(
        (analysis.wordCount.score * 0.15) +
        (analysis.keywordPlacement.score * 0.25) +
        (analysis.structureOptimization.score * 0.25) +
        (analysis.expertiseScore.score * 0.20) +
        (analysis.engagementScore.score * 0.15)
    );
    
    // 네이버 최적화 여부 판단
    analysis.naverOptimized = analysis.overall >= 80 && 
                             analysis.keywordPlacement.score >= 80 &&
                             analysis.structureOptimization.score >= 75;
    
    return analysis;
}

// 키워드 배치 분석 (네이버 SEO 핵심)
function analyzeKeywordPlacement(title, content) {
    if (!currentTopic) {
        return { score: 50, placements: [], details: {} };
    }
    
    const keywords = currentTopic.keywords;
    const placements = [];
    let score = 0;
    
    // 1. 제목에 핵심 키워드 포함 (25점)
    const titleHasKeyword = keywords.some(keyword => 
        title.toLowerCase().includes(keyword.toLowerCase())
    );
    if (titleHasKeyword) {
        placements.push("제목");
        score += 25;
    }
    
    // 2. 첫 문단에 키워드 포함 (20점)
    const firstParagraph = content.split('\n\n')[0] || '';
    const firstParaHasKeyword = keywords.some(keyword => 
        firstParagraph.toLowerCase().includes(keyword.toLowerCase())
    );
    if (firstParaHasKeyword) {
        placements.push("첫문단");
        score += 20;
    }
    
    // 3. 소제목(H2, H3)에 키워드 포함 (25점)
    const headings = content.match(/^#{2,3}\s+(.+)/gm) || [];
    const headingHasKeyword = headings.some(heading => 
        keywords.some(keyword => 
            heading.toLowerCase().includes(keyword.toLowerCase())
        )
    );
    if (headingHasKeyword) {
        placements.push("소제목");
        score += 25;
    }
    
    // 4. 본문 전체 키워드 밀도 (15점)
    const keywordDensity = calculateKeywordDensityScore(content, keywords);
    if (keywordDensity >= 1.5 && keywordDensity <= 4.0) {
        placements.push("본문밀도");
        score += 15;
    }
    
    // 5. 마지막 문단에 키워드 포함 (15점)
    const lastParagraph = content.split('\n\n').slice(-1)[0] || '';
    const lastParaHasKeyword = keywords.some(keyword => 
        lastParagraph.toLowerCase().includes(keyword.toLowerCase())
    );
    if (lastParaHasKeyword) {
        placements.push("마지막문단");
        score += 15;
    }
    
    return {
        score: Math.min(100, score),
        placements: placements,
        details: {
            title: titleHasKeyword,
            firstParagraph: firstParaHasKeyword,
            headings: headingHasKeyword,
            density: keywordDensity,
            lastParagraph: lastParaHasKeyword
        }
    };
}

// 네이버 최적화 구조 분석
function analyzeNaverStructure(content) {
    let score = 0;
    const details = {};
    
    // 1. 소제목 개수 (H2, H3) - 30점
    const h2Count = (content.match(/^##\s/gm) || []).length;
    const h3Count = (content.match(/^###\s/gm) || []).length;
    const totalHeadings = h2Count + h3Count;
    
    if (totalHeadings >= 3 && totalHeadings <= 8) {
        score += 30;
        details.headings = "optimal";
    } else if (totalHeadings >= 1) {
        score += 15;
        details.headings = "fair";
    } else {
        details.headings = "poor";
    }
    
    // 2. 목록 사용 (네이버 선호) - 25점
    const bulletLists = (content.match(/^[\-\*\+]\s/gm) || []).length;
    const numberedLists = (content.match(/^\d+\.\s/gm) || []).length;
    const totalLists = bulletLists + numberedLists;
    
    if (totalLists >= 5) {
        score += 25;
        details.lists = "excellent";
    } else if (totalLists >= 2) {
        score += 15;
        details.lists = "good";
    } else if (totalLists >= 1) {
        score += 8;
        details.lists = "fair";
    } else {
        details.lists = "poor";
    }
    
    // 3. 강조 구문 (**굵게**) - 20점
    const boldText = (content.match(/\*\*[^*]+\*\*/g) || []).length;
    if (boldText >= 5) {
        score += 20;
        details.emphasis = "excellent";
    } else if (boldText >= 2) {
        score += 12;
        details.emphasis = "good";
    } else if (boldText >= 1) {
        score += 6;
        details.emphasis = "fair";
    } else {
        details.emphasis = "poor";
    }
    
    // 4. 단락 구조 (적절한 문단 나누기) - 15점
    const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    if (paragraphs.length >= 5 && paragraphs.length <= 15) {
        score += 15;
        details.paragraphs = "optimal";
    } else if (paragraphs.length >= 3) {
        score += 8;
        details.paragraphs = "fair";
    } else {
        details.paragraphs = "poor";
    }
    
    // 5. 네이버 선호 구조 요소 - 10점
    const hasIntro = /^#+\s*(?:서론|소개|시작|들어가며)/mi.test(content);
    const hasConclusion = /^#+\s*(?:결론|마무리|정리|끝으로)/mi.test(content);
    const hasFAQ = /^#+\s*(?:FAQ|자주|질문|궁금)/mi.test(content);
    
    let structureBonus = 0;
    if (hasIntro) structureBonus += 3;
    if (hasConclusion) structureBonus += 4;
    if (hasFAQ) structureBonus += 3;
    
    score += structureBonus;
    details.structure = { hasIntro, hasConclusion, hasFAQ };
    
    return {
        score: Math.min(100, score),
        details: details,
        recommendations: generateStructureRecommendations(details)
    };
}

// 사용자 참여 유도 분석
function analyzeEngagement(content) {
    let score = 0;
    const details = {};
    
    // 1. CTA (Call to Action) 포함 - 40점
    const ctaPatterns = [
        /댓글로.*알려주세요/gi,
        /공유.*부탁드립니다/gi,
        /좋아요.*눌러주세요/gi,
        /구독.*해주세요/gi,
        /팔로우.*해주세요/gi,
        /문의.*주세요/gi,
        /상담.*받아보세요/gi,
        /클릭.*해보세요/gi
    ];
    
    let ctaCount = 0;
    ctaPatterns.forEach(pattern => {
        if (pattern.test(content)) ctaCount++;
    });
    
    if (ctaCount >= 3) {
        score += 40;
        details.cta = "excellent";
    } else if (ctaCount >= 2) {
        score += 25;
        details.cta = "good";
    } else if (ctaCount >= 1) {
        score += 15;
        details.cta = "fair";
    } else {
        details.cta = "poor";
    }
    
    // 2. 질문형 문장 (댓글 유도) - 30점
    const questionCount = (content.match(/[?？]/g) || []).length;
    if (questionCount >= 3) {
        score += 30;
        details.questions = "excellent";
    } else if (questionCount >= 1) {
        score += 15;
        details.questions = "good";
    } else {
        details.questions = "poor";
    }
    
    // 3. 개인적 경험/의견 요청 - 20점
    const personalPatterns = [
        /여러분.*경험/gi,
        /의견.*남겨주세요/gi,
        /생각.*어떠신가요/gi,
        /경험.*공유/gi,
        /어떻게.*생각하시나요/gi
    ];
    
    let personalCount = 0;
    personalPatterns.forEach(pattern => {
        if (pattern.test(content)) personalCount++;
    });
    
    if (personalCount >= 2) {
        score += 20;
        details.personal = "excellent";
    } else if (personalCount >= 1) {
        score += 10;
        details.personal = "good";
    } else {
        details.personal = "poor";
    }
    
    // 4. 소셜 미디어 언급 - 10점
    const socialPatterns = [
        /인스타그램/gi, /페이스북/gi, /카카오톡/gi, 
        /유튜브/gi, /틱톡/gi, /공유/gi
    ];
    
    const hasSocial = socialPatterns.some(pattern => pattern.test(content));
    if (hasSocial) {
        score += 10;
        details.social = "included";
    } else {
        details.social = "none";
    }
    
    return {
        score: Math.min(100, score),
        details: details,
        ctaCount: ctaCount,
        questionCount: questionCount
    };
}

// 키워드 밀도 점수 계산
function calculateKeywordDensityScore(content, keywords) {
    const words = content.split(/\s+/).filter(w => w.length > 0);
    const totalWords = words.length;
    
    if (totalWords === 0) return 0;
    
    let totalKeywordCount = 0;
    keywords.forEach(keyword => {
        const keywordCount = content.toLowerCase().split(keyword.toLowerCase()).length - 1;
        totalKeywordCount += keywordCount;
    });
    
    return (totalKeywordCount / totalWords) * 100;
}

// SEO 도구 함수들
function generateSEOTitle() {
    if (!currentTopic) {
        showNotification('warning', '주제 선택 필요', '먼저 주제를 선택해주세요.');
        return;
    }
    
    const targetData = targetAudienceData[currentTargetAudience];
    const targetName = targetData ? targetData.name : '전문가들';
    
    const titlePatterns = [
        `${currentTopic.title} | ${targetName} 필수 가이드`,
        `2024년 최신 ${currentTopic.keywords[0]} 완전정복`,
        `${currentTopic.keywords[0]} 전문가가 알려주는 실전 노하우`,
        `${targetName}을 위한 ${currentTopic.keywords[0]} 핵심 전략`,
        `실무진이 인정한 ${currentTopic.keywords[0]} 베스트 가이드`
    ];
    
    const randomTitle = titlePatterns[Math.floor(Math.random() * titlePatterns.length)];
    
    const seoTitleInput = document.getElementById('seoTitle');
    if (seoTitleInput) {
        seoTitleInput.value = randomTitle;
        updateCharCounter('seoTitle', 'seoTitleCounter', 60);
    }
    
    showNotification('success', 'SEO 제목 생성', 'SEO 최적화된 제목이 생성되었습니다.');
}

function generateMetaDescription() {
    if (!currentTopic) {
        showNotification('warning', '주제 선택 필요', '먼저 주제를 선택해주세요.');
        return;
    }
    
    const targetData = targetAudienceData[currentTargetAudience];
    const targetName = targetData ? targetData.name : '전문가들';
    const keywords = currentTopic.keywords.slice(0, 3).join(', ');
    
    const metaTemplate = `${currentTopic.title}에 대한 ${targetName} 전용 가이드입니다. ${keywords} 관련 실무 노하우와 전문 팁을 상세히 알아보세요. 클릭해서 확인하세요!`;
    
    const metaDescInput = document.getElementById('metaDescription');
    if (metaDescInput) {
        metaDescInput.value = metaTemplate;
        updateCharCounter('metaDescription', 'metaDescCounter', 150);
    }
    
    showNotification('success', '메타 설명 생성', '클릭률을 높이는 메타 설명이 생성되었습니다.');
}

function suggestKeywords() {
    if (!currentTopic) {
        showNotification('warning', '주제 선택 필요', '먼저 주제를 선택해주세요.');
        return;
    }
    
    const suggestions = document.getElementById('keywordSuggestions');
    if (!suggestions) return;
    
    // 타겟별 추천 키워드 생성
    const baseKeywords = currentTopic.keywords;
    const targetData = targetAudienceData[currentTargetAudience];
    
    let additionalKeywords = [];
    if (targetData && targetData.expertTerms) {
        additionalKeywords = targetData.expertTerms.slice(0, 5);
    } else {
        additionalKeywords = ["전문가", "노하우", "가이드", "팁", "방법"];
    }
    
    const allKeywords = [...baseKeywords, ...additionalKeywords];
    
    suggestions.innerHTML = allKeywords.map(keyword => 
        `<span class="keyword-suggestion" onclick="addKeyword('${keyword}')">${keyword}</span>`
    ).join('');
    
    showNotification('info', '키워드 제안', '추천 키워드가 생성되었습니다. 클릭하여 추가하세요.');
}

function addKeyword(keyword) {
    const primaryKeywords = document.getElementById('primaryKeywords');
    if (primaryKeywords) {
        const currentValue = primaryKeywords.value;
        const keywords = currentValue ? currentValue.split(',').map(k => k.trim()) : [];
        
        if (!keywords.includes(keyword)) {
            keywords.push(keyword);
            primaryKeywords.value = keywords.join(', ');
        }
    }
}

function checkSEOScore() {
    const title = document.getElementById('postTitle')?.value || '';
    const content = document.getElementById('postContent')?.value || '';
    
    if (!title || !content) {
        showNotification('warning', '내용 필요', '제목과 본문을 입력해주세요.');
        return;
    }
    
    const seoAnalysis = analyzeNaverSEOQuality(title, content);
    updateNaverSEODisplay(seoAnalysis);
    
    const message = seoAnalysis.naverOptimized ? 
        '네이버 상위 노출에 최적화되었습니다!' : 
        `SEO 점수: ${seoAnalysis.overall}/100 - 개선이 필요합니다.`;
    
    showNotification(
        seoAnalysis.naverOptimized ? 'success' : 'warning', 
        'SEO 분석 완료', 
        message
    );
}

// 문자 수 카운터 업데이트
function updateCharCounter(inputId, counterId, maxLength) {
    const input = document.getElementById(inputId);
    const counter = document.getElementById(counterId);
    
    if (input && counter) {
        const length = input.value.length;
        counter.textContent = `${length}/${maxLength}자`;
        
        // 색상 변경
        counter.className = 'char-counter';
        if (length > maxLength) {
            counter.classList.add('error');
        } else if (length >= maxLength * 0.8) {
            counter.classList.add('warning');
        } else if (length >= maxLength * 0.5) {
            counter.classList.add('success');
        }
    }
}

// 네이버 SEO 표시 업데이트
function updateNaverSEODisplay(analysis) {
    // SEO 상태 업데이트
    const seoStatus = document.getElementById('seoStatus');
    if (seoStatus) {
        const statusIcon = analysis.naverOptimized ? '✅' : analysis.overall >= 70 ? '⚠️' : '❌';
        const statusText = analysis.naverOptimized ? 
            '네이버 SEO 최적화 완료' : 
            analysis.overall >= 70 ? 
            '네이버 SEO 개선 필요' : 
            'SEO 최적화 부족';
        
        seoStatus.innerHTML = `
            <span class="status-icon">${statusIcon}</span>
            <span class="status-text">${statusText}</span>
        `;
    }
    
    // 전체 점수 업데이트
    const overallQuality = document.getElementById('overallQuality');
    if (overallQuality) {
        overallQuality.textContent = analysis.overall;
        overallQuality.className = 'quality-score ' + getQualityClass(analysis.overall);
        
        if (analysis.naverOptimized) {
            overallQuality.classList.add('naver-optimized');
        }
    }
    
    // 개별 메트릭 업데이트
    updateMetric('wordCount', analysis.wordCount.count, analysis.wordCount.score);
    updateMetric('keywordPlacement', `${analysis.keywordPlacement.placements.length}/5`, analysis.keywordPlacement.score);
    updateMetric('structureScore', analysis.structureOptimization.score, analysis.structureOptimization.score);
    updateMetric('expertiseScore', analysis.expertiseScore.score, analysis.expertiseScore.score);
    updateMetric('engagementScore', analysis.engagementScore.score, analysis.engagementScore.score);
    
    // SEO 추천사항 업데이트
    updateSEORecommendations(analysis);
}

// SEO 추천사항 업데이트
function updateSEORecommendations(analysis) {
    const container = document.getElementById('seoRecommendations');
    if (!container) return;
    
    const recommendations = [];
    
    // 우선순위별 추천사항 생성
    if (analysis.wordCount.score < 70) {
        const priority = analysis.wordCount.score < 40 ? 'high' : 'medium';
        const message = analysis.wordCount.count < seoQualityStandards.wordCount.min ? 
            `글 길이가 짧습니다. 네이버는 1500자 이상의 글을 선호합니다. (현재: ${analysis.wordCount.count}자)` :
            `글이 너무 깁니다. 3000-5000자 사이로 조정해보세요.`;
        recommendations.push({ priority, message });
    }
    
    if (analysis.keywordPlacement.score < 80) {
        const missing = [];
        if (!analysis.keywordPlacement.details.title) missing.push('제목');
        if (!analysis.keywordPlacement.details.firstParagraph) missing.push('첫 문단');
        if (!analysis.keywordPlacement.details.headings) missing.push('소제목');
        
        recommendations.push({
            priority: 'high',
            message: `핵심 키워드를 다음 위치에 추가하세요: ${missing.join(', ')}`
        });
    }
    
    if (analysis.structureOptimization.score < 75) {
        recommendations.push({
            priority: 'medium',
            message: '소제목(##), 목록(-), 강조(**굵게**)를 더 활용해 구조를 개선하세요.'
        });
    }
    
    if (analysis.engagementScore.score < 60) {
        recommendations.push({
            priority: 'medium',
            message: '댓글 유도, 공유 요청 등 사용자 참여를 높이는 CTA를 추가하세요.'
        });
    }
    
    if (recommendations.length === 0) {
        recommendations.push({
            priority: 'low',
            message: '네이버 SEO 최적화가 잘 되어 있습니다! 상위 노출 가능성이 높습니다.'
        });
    }
    
    container.innerHTML = `
        <h4>🎯 네이버 상위노출 개선사항</h4>
        ${recommendations.map(rec => 
            `<div class="recommendation priority-${rec.priority}">${rec.message}</div>`
        ).join('')}
    `;
}

// 구조 추천사항 생성
function generateStructureRecommendations(details) {
    const recommendations = [];
    
    if (details.headings === 'poor') {
        recommendations.push('소제목(## 제목)을 3-5개 추가하세요.');
    }
    
    if (details.lists === 'poor') {
        recommendations.push('목록 형태(-또는 1.)로 정보를 정리하세요.');
    }
    
    if (details.emphasis === 'poor') {
        recommendations.push('중요한 내용은 **굵게** 강조하세요.');
    }
    
    return recommendations;
}

// 글자 수 분석
function analyzeWordCount(content) {
    const count = content.length;
    const standards = qualityStandards.wordCount;
    
    let score = 0;
    if (count >= standards.min && count <= standards.max) {
        if (count >= standards.ideal - 200 && count <= standards.ideal + 200) {
            score = 100;
        } else {
            score = Math.max(70, 100 - Math.abs(count - standards.ideal) / 10);
        }
    } else if (count < standards.min) {
        score = (count / standards.min) * 60;
    } else {
        score = Math.max(40, 100 - (count - standards.max) / 50);
    }
    
    return {
        count: count,
        score: Math.round(score),
        status: score >= 70 ? 'good' : score >= 50 ? 'fair' : 'poor'
    };
}

// 가독성 분석
function analyzeReadability(content) {
    // 간단한 가독성 분석 (실제로는 더 복잡한 알고리즘 사용)
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const words = content.split(/\s+/).filter(w => w.length > 0);
    
    if (sentences.length === 0 || words.length === 0) {
        return { score: 0, status: 'poor' };
    }
    
    const avgWordsPerSentence = words.length / sentences.length;
    const avgSyllablesPerWord = calculateAvgSyllables(words);
    
    // Flesch-Kincaid 유사 공식 (한국어 조정)
    let score = 100 - (avgWordsPerSentence * 1.5) - (avgSyllablesPerWord * 85);
    score = Math.max(0, Math.min(100, score));
    
    return {
        score: Math.round(score),
        avgWordsPerSentence: Math.round(avgWordsPerSentence * 10) / 10,
        status: score >= 70 ? 'good' : score >= 50 ? 'fair' : 'poor'
    };
}

// 음절 수 계산 (근사치)
function calculateAvgSyllables(words) {
    const koreanSyllables = words.reduce((sum, word) => {
        return sum + (word.match(/[가-힣]/g) || []).length;
    }, 0);
    
    const englishSyllables = words.reduce((sum, word) => {
        const englishWord = word.replace(/[^a-zA-Z]/g, '');
        return sum + Math.max(1, (englishWord.match(/[aeiouAEIOU]/g) || []).length);
    }, 0);
    
    return (koreanSyllables + englishSyllables) / words.length || 1;
}

// 키워드 밀도 분석
function analyzeKeywordDensity(content) {
    if (!currentTopic) {
        return { score: 50, density: 0, status: 'fair' };
    }
    
    const words = content.toLowerCase().split(/\s+/);
    const totalWords = words.length;
    
    let totalKeywordCount = 0;
    currentTopic.keywords.forEach(keyword => {
        const keywordCount = content.toLowerCase().split(keyword.toLowerCase()).length - 1;
        totalKeywordCount += keywordCount;
    });
    
    const density = (totalKeywordCount / totalWords) * 100;
    const standards = qualityStandards.keywordDensity;
    
    let score = 0;
    if (density >= standards.min && density <= standards.max) {
        if (density >= standards.ideal - 0.5 && density <= standards.ideal + 0.5) {
            score = 100;
        } else {
            score = Math.max(70, 100 - Math.abs(density - standards.ideal) * 10);
        }
    } else if (density < standards.min) {
        score = (density / standards.min) * 60;
    } else {
        score = Math.max(30, 100 - (density - standards.max) * 15);
    }
    
    return {
        density: Math.round(density * 10) / 10,
        score: Math.round(score),
        status: score >= 70 ? 'good' : score >= 50 ? 'fair' : 'poor'
    };
}

// 구조 분석
function analyzeStructure(content) {
    let score = 0;
    
    // 헤더 구조 확인
    const h1Count = (content.match(/^# /gm) || []).length;
    const h2Count = (content.match(/^## /gm) || []).length;
    const h3Count = (content.match(/^### /gm) || []).length;
    
    // 목록 구조 확인
    const listItems = (content.match(/^[-*+] /gm) || []).length;
    const orderedLists = (content.match(/^\d+\. /gm) || []).length;
    
    // 단락 구조 확인
    const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    
    // 점수 계산
    if (h1Count >= 1) score += 20; // 제목
    if (h2Count >= 2) score += 25; // 주요 섹션
    if (h3Count >= 1) score += 15; // 세부 섹션
    if (listItems + orderedLists >= 3) score += 20; // 목록 사용
    if (paragraphs.length >= 5) score += 20; // 적절한 단락 구성
    
    return {
        score: Math.min(100, score),
        headers: { h1: h1Count, h2: h2Count, h3: h3Count },
        lists: listItems + orderedLists,
        paragraphs: paragraphs.length,
        status: score >= 70 ? 'good' : score >= 50 ? 'fair' : 'poor'
    };
}

// 전문성 분석
function analyzeExpertise(content) {
    const expertTerms = [
        '헤어게이터', '모발', '두피', '큐티클', '케라틴', '콜라겐',
        '트리트먼트', '헤어팩', '세럼', '에센스', '샴푸', '컨디셔너',
        '스타일링', '펌', '염색', '탈색', '영양', '수분', '단백질',
        '실리콘', '황산계', '파라벤', 'pH', '산성', '알칼리성'
    ];
    
    let expertTermCount = 0;
    expertTerms.forEach(term => {
        const regex = new RegExp(term, 'gi');
        const matches = content.match(regex);
        if (matches) expertTermCount += matches.length;
    });
    
    // 전문적 표현 패턴 확인
    const expertPatterns = [
        /전문가/g, /연구/g, /임상/g, /효과적/g, /권장/g,
        /성분/g, /함유/g, /농도/g, /비율/g, /측정/g
    ];
    
    let patternCount = 0;
    expertPatterns.forEach(pattern => {
        const matches = content.match(pattern);
        if (matches) patternCount += matches.length;
    });
    
    const totalWords = content.split(/\s+/).length;
    const expertiseRatio = (expertTermCount + patternCount) / totalWords;
    
    let score = Math.min(100, expertiseRatio * 1000);
    
    return {
        score: Math.round(score),
        expertTerms: expertTermCount,
        patterns: patternCount,
        ratio: Math.round(expertiseRatio * 1000) / 1000,
        status: score >= 70 ? 'good' : score >= 50 ? 'fair' : 'poor'
    };
}

// 품질 표시 업데이트
function updateQualityDisplay(quality) {
    // 전체 점수
    const overallQuality = document.getElementById('overallQuality');
    if (overallQuality) {
        overallQuality.textContent = quality.overall;
        overallQuality.className = 'quality-score ' + getQualityClass(quality.overall);
    }
    
    // 개별 메트릭 업데이트
    updateMetric('wordCount', quality.wordCount.count, quality.wordCount.score);
    updateMetric('readability', quality.readability.score, quality.readability.score);
    updateMetric('keywordDensity', quality.keywordDensity.density + '%', quality.keywordDensity.score);
    updateMetric('structureScore', quality.structure.score, quality.structure.score);
    updateMetric('expertiseScore', quality.expertise.score, quality.expertise.score);
    
    // 추천사항 업데이트
    updateRecommendations(quality);
}

// 메트릭 업데이트
function updateMetric(metricId, value, score) {
    const valueElement = document.getElementById(metricId);
    const barElement = document.getElementById(metricId + 'Bar');
    
    if (valueElement) valueElement.textContent = value;
    if (barElement) {
        barElement.style.width = score + '%';
        barElement.className = 'metric-fill ' + getQualityClass(score);
    }
}

// 품질 클래스 반환
function getQualityClass(score) {
    if (score >= 80) return 'excellent';
    if (score >= 70) return 'good';
    if (score >= 50) return 'fair';
    return 'poor';
}

// 추천사항 업데이트
function updateRecommendations(quality) {
    const container = document.getElementById('qualityRecommendations');
    if (!container) return;
    
    const recommendations = [];
    
    if (quality.wordCount.score < 70) {
        if (quality.wordCount.count < qualityStandards.wordCount.min) {
            recommendations.push('글 길이가 짧습니다. 더 자세한 설명을 추가해보세요.');
        } else {
            recommendations.push('글이 너무 깁니다. 핵심 내용을 중심으로 간결하게 정리해보세요.');
        }
    }
    
    if (quality.readability.score < 70) {
        recommendations.push('문장을 더 짧고 명확하게 작성해보세요.');
    }
    
    if (quality.keywordDensity.score < 70) {
        if (quality.keywordDensity.density < qualityStandards.keywordDensity.min) {
            recommendations.push('핵심 키워드를 더 자주 사용해보세요.');
        } else {
            recommendations.push('키워드 사용이 과도합니다. 자연스럽게 줄여보세요.');
        }
    }
    
    if (quality.structure.score < 70) {
        recommendations.push('헤더와 목록을 활용해 구조를 개선해보세요.');
    }
    
    if (quality.expertise.score < 70) {
        recommendations.push('헤어케어 전문 용어와 표현을 더 활용해보세요.');
    }
    
    if (recommendations.length === 0) {
        recommendations.push('훌륭한 품질의 글입니다! 발행 준비가 완료되었습니다.');
    }
    
    container.innerHTML = recommendations.map(rec => 
        `<div class="recommendation">${rec}</div>`
    ).join('');
}

// 품질 메트릭 실시간 업데이트
function updateQualityMetrics() {
    const title = document.getElementById('postTitle')?.value || '';
    const content = document.getElementById('postContent')?.value || '';
    
    if (title || content) {
        checkQuality();
    }
}

// 미리보기
function previewContent() {
    const title = document.getElementById('postTitle')?.value || '제목 없음';
    const content = document.getElementById('postContent')?.value || '내용 없음';
    
    const previewContainer = document.getElementById('previewContainer');
    if (!previewContainer) return;
    
    // 마크다운을 HTML로 변환 (간단한 변환)
    let htmlContent = content
        .replace(/^# (.+)/gm, '<h1>$1</h1>')
        .replace(/^## (.+)/gm, '<h2>$1</h2>')
        .replace(/^### (.+)/gm, '<h3>$1</h3>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/^[-*+] (.+)/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^(.+)$/gm, '<p>$1</p>');
    
    previewContainer.innerHTML = `
        <div class="preview-header">
            <h1>${title}</h1>
            <div class="preview-meta">
                <span>카테고리: ${getCategoryDisplayName(document.getElementById('postCategory')?.value || 'basic')}</span>
                <span>작성일: ${new Date().toLocaleDateString('ko-KR')}</span>
            </div>
        </div>
        <div class="preview-content">
            ${htmlContent}
        </div>
    `;
    
    showModal('previewModal');
    logActivity('미리보기', '콘텐츠 미리보기를 확인했습니다.');
}

// 이미지 생성
async function generateImage() {
    const prompt = document.getElementById('imagePrompt')?.value;
    
    if (!prompt) {
        showNotification('warning', '프롬프트 필요', '이미지 설명을 입력해주세요.');
        return;
    }
    
    if (!aiConfig.openai.connected) {
        showNotification('warning', 'OpenAI 연결 필요', 'OpenAI API를 먼저 연결해주세요.');
        return;
    }
    
    const generateBtn = event.target;
    generateBtn.textContent = '생성 중...';
    generateBtn.disabled = true;
    
    try {
        // 실제 구현에서는 실제 API 호출
        const imageUrl = await generateImageWithAI(prompt);
        addGeneratedImage(imageUrl, prompt);
        
        showNotification('success', '이미지 생성 완료', '새로운 이미지가 생성되었습니다.');
        logActivity('이미지 생성', `"${prompt}" 프롬프트로 이미지를 생성했습니다.`);
        
    } catch (error) {
        showNotification('error', '이미지 생성 실패', error.message);
        logActivity('이미지 생성 실패', error.message, 'error');
    }
    
    generateBtn.textContent = '이미지 생성';
    generateBtn.disabled = false;
}

// AI 이미지 생성 (시뮬레이션)
async function generateImageWithAI(prompt) {
    return new Promise((resolve) => {
        setTimeout(() => {
            // 실제로는 OpenAI DALL-E API 호출
            const sampleImages = [
                'https://images.unsplash.com/photo-1522337360788-8b13dee7a37e?w=400',
                'https://images.unsplash.com/photo-1562322140-8baeececf3df?w=400',
                'https://images.unsplash.com/photo-1580618432485-c1f0c1e6da84?w=400'
            ];
            
            const randomImage = sampleImages[Math.floor(Math.random() * sampleImages.length)];
            resolve(randomImage);
        }, 2000);
    });
}

// 생성된 이미지 추가
function addGeneratedImage(imageUrl, prompt) {
    const container = document.getElementById('generatedImages');
    if (!container) return;
    
    const imageDiv = document.createElement('div');
    imageDiv.className = 'image-item';
    imageDiv.innerHTML = `
        <img src="${imageUrl}" alt="${prompt}">
        <div class="image-actions">
            <button class="select-image" onclick="selectImage('${imageUrl}')">선택</button>
            <button class="delete-image" onclick="deleteImage(this)">삭제</button>
        </div>
    `;
    
    container.appendChild(imageDiv);
}

// 이미지 선택/삭제
function selectImage(imageUrl) {
    showNotification('success', '이미지 선택됨', '선택된 이미지가 포스트에 적용됩니다.');
    logActivity('이미지 선택', '포스트용 이미지를 선택했습니다.');
}

function deleteImage(button) {
    const imageItem = button.closest('.image-item');
    if (imageItem) {
        imageItem.remove();
        logActivity('이미지 삭제', '생성된 이미지를 삭제했습니다.');
    }
}

// 콘텐츠 발행
async function publishContent() {
    const title = document.getElementById('postTitle')?.value;
    const content = document.getElementById('postContent')?.value;
    
    if (!title || !content) {
        showNotification('warning', '내용 부족', '제목과 본문을 모두 입력해주세요.');
        return;
    }
    
    // 품질 검사
    if (!qualityData || qualityData.overall < 60) {
        const quality = await checkQuality();
        if (quality.overall < 60) {
            showNotification('warning', '품질 기준 미달', '품질 점수가 60점 미만입니다. 내용을 개선해주세요.');
            return;
        }
    }
    
    const publishBtn = document.getElementById('publishBtn');
    const btnText = publishBtn.querySelector('.btn-text');
    const btnLoader = publishBtn.querySelector('.btn-loader');
    
    // 발행 시작
    publishBtn.disabled = true;
    btnText.style.display = 'none';
    btnLoader.style.display = 'inline-block';
    
    try {
        // 실제 구현에서는 네이버 블로그 API 호출
        await simulatePublishing();
        
        // 발행 성공 처리
        systemStats.publishedPosts++;
        updateSystemStats();
        
        showNotification('success', '발행 완료', '네이버 블로그에 성공적으로 발행되었습니다.');
        logActivity('발행 성공', `"${title}" 글이 네이버 블로그에 발행되었습니다.`, 'success');
        
        // 에디터 초기화
        clearEditor();
        
    } catch (error) {
        showNotification('error', '발행 실패', error.message);
        logActivity('발행 실패', error.message, 'error');
    }
    
    // 버튼 상태 복원
    publishBtn.disabled = false;
    btnText.style.display = 'inline';
    btnLoader.style.display = 'none';
}

// 발행 시뮬레이션
async function simulatePublishing() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            // 90% 성공률 시뮬레이션
            if (Math.random() > 0.1) {
                resolve({ success: true, postId: 'post_' + Date.now() });
            } else {
                reject(new Error('네트워크 오류로 발행에 실패했습니다.'));
            }
        }, 3000);
    });
}

// 에디터 초기화
function clearEditor() {
    const elements = [
        'postTitle', 'postContent', 'postTags', 'metaDescription', 'imagePrompt'
    ];
    
    elements.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.value = '';
    });
    
    const generatedImages = document.getElementById('generatedImages');
    if (generatedImages) generatedImages.innerHTML = '';
    
    const qualityRecommendations = document.getElementById('qualityRecommendations');
    if (qualityRecommendations) qualityRecommendations.innerHTML = '';
    
    currentTopic = null;
    generatedContent = null;
    qualityData = null;
    
    updateSelectedTopicDisplay();
}

// 임시저장
function saveAsDraft() {
    const title = document.getElementById('postTitle')?.value || '임시저장_' + Date.now();
    const content = document.getElementById('postContent')?.value || '';
    
    // 로컬 스토리지에 저장 (실제로는 서버에 저장)
    const draftData = {
        title, content,
        timestamp: new Date().toISOString(),
        topic: currentTopic
    };
    
    localStorage.setItem('hairgator_draft_' + Date.now(), JSON.stringify(draftData));
    
    showNotification('success', '임시저장 완료', '작업 내용이 임시저장되었습니다.');
    logActivity('임시저장', `"${title}" 글을 임시저장했습니다.`);
}

// 자동화 기능
function toggleAutomation() {
    const toggle = document.getElementById('automationEnabled');
    automationEnabled = toggle.checked;
    
    if (automationEnabled) {
        startAutomation();
        showNotification('success', '자동화 시작', '블로그 자동화가 활성화되었습니다.');
        logActivity('자동화 시작', '블로그 자동화 시스템이 시작되었습니다.');
    } else {
        stopAutomation();
        showNotification('info', '자동화 중지', '블로그 자동화가 비활성화되었습니다.');
        logActivity('자동화 중지', '블로그 자동화 시스템이 중지되었습니다.');
    }
}

function startAutomation() {
    // 자동화 스케줄 설정
    const frequency = document.getElementById('publishFrequency')?.value || 'daily';
    const time = document.getElementById('publishTime')?.value || '09:00';
    
    // 실제 구현에서는 cron job 설정
    console.log(`자동화 시작: ${frequency} at ${time}`);
}

function stopAutomation() {
    // 자동화 스케줄 제거
    console.log('자동화 중지');
}

// 스케줄링 관련 함수들
function schedulePublish() {
    const publishDate = document.getElementById('publishDate')?.value;
    
    if (!publishDate) {
        showNotification('warning', '날짜 선택 필요', '예약 발행 날짜를 선택해주세요.');
        return;
    }
    
    const title = document.getElementById('postTitle')?.value || '제목 없음';
    const scheduleDate = new Date(publishDate);
    
    // 스케줄 목록에 추가
    addToScheduleList(title, scheduleDate);
    
    showNotification('success', '예약 완료', `${scheduleDate.toLocaleString('ko-KR')}에 발행 예약되었습니다.`);
    logActivity('예약 발행', `"${title}" 글이 ${scheduleDate.toLocaleString('ko-KR')}에 예약되었습니다.`);
}

function addToScheduleList(title, date) {
    const scheduleList = document.getElementById('scheduleList');
    if (!scheduleList) return;
    
    const scheduleItem = document.createElement('div');
    scheduleItem.className = 'schedule-item';
    scheduleItem.innerHTML = `
        <div class="schedule-content">
            <div class="schedule-title">${title}</div>
            <div class="schedule-time">${date.toLocaleString('ko-KR')}</div>
        </div>
        <div class="schedule-actions">
            <button class="edit-schedule">수정</button>
            <button class="cancel-schedule" onclick="cancelSchedule(this)">취소</button>
        </div>
    `;
    
    scheduleList.appendChild(scheduleItem);
}

function cancelSchedule(button) {
    const scheduleItem = button.closest('.schedule-item');
    if (scheduleItem) {
        scheduleItem.remove();
        showNotification('info', '예약 취소', '예약 발행이 취소되었습니다.');
        logActivity('예약 취소', '예약된 발행을 취소했습니다.');
    }
}

// 주제 관리
function showTopicModal() {
    showModal('topicModal');
}

function addNewTopic() {
    const title = document.getElementById('newTopicTitle')?.value;
    const category = document.getElementById('newTopicCategory')?.value;
    const keywords = document.getElementById('newTopicKeywords')?.value;
    const target = document.getElementById('newTopicTarget')?.value;
    
    if (!title || !keywords) {
        showNotification('warning', '필수 정보 부족', '주제와 키워드를 입력해주세요.');
        return;
    }
    
    const newTopic = {
        id: Date.now(),
        title: title,
        category: category,
        keywords: keywords.split(',').map(k => k.trim()),
        targetAudience: getTargetAudienceDisplayName(target),
        difficulty: target
    };
    
    // 해당 카테고리에 추가
    if (!haircareTopics[category]) {
        haircareTopics[category] = [];
    }
    haircareTopics[category].push(newTopic);
    
    // 화면 업데이트
    loadTopics();
    
    // 모달 닫기
    closeModal('topicModal');
    
    // 입력 필드 초기화
    document.getElementById('newTopicTitle').value = '';
    document.getElementById('newTopicKeywords').value = '';
    
    showNotification('success', '주제 추가 완료', '새로운 주제가 추가되었습니다.');
    logActivity('주제 추가', `"${title}" 주제가 추가되었습니다.`);
}

function getTargetAudienceDisplayName(target) {
    const displayNames = {
        beginner: '헤어케어 초보자',
        intermediate: '일반인',
        expert: '전문가'
    };
    return displayNames[target] || target;
}

function deleteTopic(topicElement) {
    if (!confirm('정말로 이 주제를 삭제하시겠습니까?')) return;
    
    const topicId = parseInt(topicElement.dataset.topicId);
    const category = topicElement.dataset.category;
    
    // 데이터에서 제거
    if (haircareTopics[category]) {
        haircareTopics[category] = haircareTopics[category].filter(topic => topic.id !== topicId);
    }
    
    // 화면에서 제거
    topicElement.remove();
    
    showNotification('success', '주제 삭제 완료', '주제가 삭제되었습니다.');
    logActivity('주제 삭제', '주제를 삭제했습니다.');
}

function editTopic(topicElement) {
    showNotification('info', '편집 기능', '주제 편집 기능은 곧 추가될 예정입니다.');
}

// 모니터링 시스템
function startMonitoring() {
    // 5분마다 시스템 상태 업데이트
    setInterval(updateSystemStatus, 5 * 60 * 1000);
    
    // 초기 상태 업데이트
    updateSystemStatus();
}

function updateSystemStatus() {
    // API 상태 체크
    const apiStatus = (aiConfig.claude.connected && aiConfig.openai.connected) ? '정상' : '일부 오류';
    document.getElementById('apiMonitor').textContent = apiStatus;
    
    // 성공률 계산 (임시)
    const successRate = systemStats.publishedPosts > 0 ? 
        Math.round((systemStats.publishedPosts / systemStats.totalPosts) * 100) : 100;
    document.getElementById('successRate').textContent = successRate + '%';
    
    // 처리 시간 (임시)
    document.getElementById('processingTime').textContent = (Math.random() * 3 + 1).toFixed(1) + '초';
    
    // 오늘 생성된 글 수 (임시)
    document.getElementById('todayGenerated').textContent = Math.floor(Math.random() * 20) + '개';
}

function refreshMonitoring() {
    updateSystemStatus();
    showNotification('info', '모니터링 새로고침', '시스템 상태가 업데이트되었습니다.');
    logActivity('모니터링 새로고침', '시스템 상태를 새로고침했습니다.');
}

// 시스템 통계 업데이트
function updateSystemStats() {
    document.getElementById('totalPosts').textContent = systemStats.totalPosts;
    document.getElementById('publishedPosts').textContent = systemStats.publishedPosts;
    document.getElementById('systemStatus').textContent = systemStats.systemStatus;
    
    // 평균 품질 점수 계산
    if (qualityData) {
        systemStats.qualityScore = qualityData.overall;
    }
    document.getElementById('qualityScore').textContent = systemStats.qualityScore;
}

// AI 상태 업데이트
function updateAIStatus() {
    const aiStatus = document.getElementById('aiStatus');
    if (!aiStatus) return;
    
    if (aiConfig.claude.connected && aiConfig.openai.connected) {
        aiStatus.textContent = '모든 서비스 연결됨';
        aiStatus.className = 'connection-status connected';
    } else if (aiConfig.claude.connected || aiConfig.openai.connected) {
        aiStatus.textContent = '일부 서비스 연결됨';
        aiStatus.className = 'connection-status partial';
    } else {
        aiStatus.textContent = '연결 대기';
        aiStatus.className = 'connection-status waiting';
    }
}

// 활동 로그 시스템
function initializeActivityLog() {
    logActivity('시스템 시작', 'HAIRGATOR 블로그 자동화 시스템이 시작되었습니다.', 'success');
}

function logActivity(action, message, type = 'info') {
    const logContainer = document.getElementById('activityLog');
    if (!logContainer) return;
    
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    
    const timestamp = new Date().toLocaleTimeString('ko-KR');
    
    logEntry.innerHTML = `
        <div class="log-message">${message}</div>
        <div class="log-time">${timestamp}</div>
        <div class="log-status ${type}">${action}</div>
    `;
    
    // 최신 로그를 맨 위에 추가
    logContainer.insertBefore(logEntry, logContainer.firstChild);
    
    // 로그 개수 제한 (최대 50개)
    const entries = logContainer.querySelectorAll('.log-entry');
    if (entries.length > 50) {
        entries[entries.length - 1].remove();
    }
}

// 자동화 설정 로드
function loadAutomationSettings() {
    // 로컬 스토리지에서 자동화 설정 로드
    const savedSettings = localStorage.getItem('hairgator_automation_settings');
    if (savedSettings) {
        try {
            const settings = JSON.parse(savedSettings);
            
            const elements = {
                'automationEnabled': settings.enabled,
                'publishFrequency': settings.frequency,
                'publishTime': settings.time,
                'maxDailyPosts': settings.maxDailyPosts
            };
            
            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element && value !== undefined) {
                    if (element.type === 'checkbox') {
                        element.checked = value;
                    } else {
                        element.value = value;
                    }
                }
            });
            
            automationEnabled = settings.enabled || false;
            
        } catch (error) {
            console.error('자동화 설정 로드 실패:', error);
        }
    }
}

// 자동화 설정 저장
function saveAutomationSettings() {
    const settings = {
        enabled: document.getElementById('automationEnabled')?.checked || false,
        frequency: document.getElementById('publishFrequency')?.value || 'daily',
        time: document.getElementById('publishTime')?.value || '09:00',
        maxDailyPosts: parseInt(document.getElementById('maxDailyPosts')?.value) || 3
    };
    
    localStorage.setItem('hairgator_automation_settings', JSON.stringify(settings));
}

// 일괄 생성 기능
async function generateBulkContent() {
    if (!aiConfig.claude.connected) {
        showNotification('warning', 'Claude 연결 필요', 'Claude API를 먼저 연결해주세요.');
        return;
    }
    
    const selectedTopics = document.querySelectorAll('.topic-item.selected');
    if (selectedTopics.length === 0) {
        showNotification('warning', '주제 선택 필요', '일괄 생성할 주제를 선택해주세요.');
        return;
    }
    
    const maxBulkGeneration = 5;
    if (selectedTopics.length > maxBulkGeneration) {
        showNotification('warning', '선택 제한', `최대 ${maxBulkGeneration}개까지만 선택 가능합니다.`);
        return;
    }
    
    if (!confirm(`선택된 ${selectedTopics.length}개 주제로 일괄 생성하시겠습니까?`)) {
        return;
    }
    
    showNotification('info', '일괄 생성 시작', `${selectedTopics.length}개 글 생성을 시작합니다.`);
    logActivity('일괄 생성 시작', `${selectedTopics.length}개 주제로 일괄 생성을 시작했습니다.`);
    
    let successCount = 0;
    let failCount = 0;
    
    for (let i = 0; i < selectedTopics.length; i++) {
        const topicElement = selectedTopics[i];
        const topicId = parseInt(topicElement.dataset.topicId);
        
        // 주제 데이터 찾기
        let topic = null;
        Object.values(haircareTopics).forEach(categoryTopics => {
            const found = categoryTopics.find(t => t.id === topicId);
            if (found) topic = found;
        });
        
        if (!topic) {
            failCount++;
            continue;
        }
        
        try {
            // 각 주제별로 콘텐츠 생성
            currentTopic = topic;
            const content = await generateHaircareContent(topic);
            
            // 자동 저장 (임시저장 형태로)
            const draftData = {
                title: content.title,
                content: content.content,
                metaDescription: content.metaDescription,
                topic: topic,
                timestamp: new Date().toISOString(),
                bulkGenerated: true
            };
            
            localStorage.setItem(`hairgator_bulk_${Date.now()}_${i}`, JSON.stringify(draftData));
            
            successCount++;
            logActivity('일괄 생성', `"${content.title}" 생성 완료 (${i + 1}/${selectedTopics.length})`);
            
            // API 레이트 리밋 고려하여 2초 대기
            if (i < selectedTopics.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
        } catch (error) {
            failCount++;
            logActivity('일괄 생성 실패', `"${topic.title}" 생성 실패: ${error.message}`, 'error');
        }
    }
    
    // 일괄 생성 완료 알림
    const message = `일괄 생성 완료! 성공: ${successCount}개, 실패: ${failCount}개`;
    showNotification(failCount === 0 ? 'success' : 'warning', '일괄 생성 완료', message);
    logActivity('일괄 생성 완료', message, failCount === 0 ? 'success' : 'warning');
    
    // 통계 업데이트
    systemStats.totalPosts += successCount;
    updateSystemStats();
    
    // 선택 해제
    selectedTopics.forEach(topic => topic.classList.remove('selected'));
}

// 네이버 블로그 설정
function configureNaver() {
    showNotification('info', '설정 기능', '네이버 블로그 연동 설정은 곧 추가될 예정입니다.');
}

// 모달 관리
function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
    }
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
    }
}

// 알림 시스템
function showNotification(type, title, message) {
    const container = document.getElementById('notificationContainer');
    if (!container) return;
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    notification.innerHTML = `
        <div class="notification-header">
            <div class="notification-title">${title}</div>
            <button class="notification-close" onclick="closeNotification(this)">&times;</button>
        </div>
        <div class="notification-body">${message}</div>
    `;
    
    container.appendChild(notification);
    
    // 자동 제거 (타입별 시간 차등)
    const autoRemoveTime = {
        success: 5000,
        info: 7000,
        warning: 10000,
        error: 12000
    };
    
    setTimeout(() => {
        if (notification.parentNode) {
            closeNotification(notification.querySelector('.notification-close'));
        }
    }, autoRemoveTime[type] || 6000);
}

function closeNotification(button) {
    const notification = button.closest('.notification');
    if (notification) {
        notification.style.animation = 'notificationSlideOut 0.3s ease forwards';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 300);
    }
}

// 유틸리티 함수들
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// 키보드 단축키
document.addEventListener('keydown', function(e) {
    // Ctrl+S: 임시저장
    if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveAsDraft();
    }
    
    // Ctrl+Enter: 콘텐츠 생성
    if (e.ctrlKey && e.key === 'Enter') {
        e.preventDefault();
        generateContent();
    }
    
    // Ctrl+P: 미리보기
    if (e.ctrlKey && e.key === 'p') {
        e.preventDefault();
        previewContent();
    }
    
    // Escape: 모달 닫기
    if (e.key === 'Escape') {
        const openModals = document.querySelectorAll('.modal[style*="block"]');
        openModals.forEach(modal => {
            closeModal(modal.id);
        });
    }
});

// 페이지 이탈 시 임시저장 확인
window.addEventListener('beforeunload', function(e) {
    const title = document.getElementById('postTitle')?.value;
    const content = document.getElementById('postContent')?.value;
    
    if ((title && title.trim()) || (content && content.trim())) {
        const confirmationMessage = '작성 중인 내용이 있습니다. 페이지를 떠나시겠습니까?';
        e.returnValue = confirmationMessage;
        return confirmationMessage;
    }
});

// 다크모드 지원 (선택사항)
function toggleDarkMode() {
    document.body.classList.toggle('dark-mode');
    const isDark = document.body.classList.contains('dark-mode');
    localStorage.setItem('hairgator_dark_mode', isDark);
    
    showNotification('info', '테마 변경', isDark ? '다크 모드가 활성화되었습니다.' : '라이트 모드가 활성화되었습니다.');
}

// 다크모드 설정 로드
function loadDarkModeSettings() {
    const isDark = localStorage.getItem('hairgator_dark_mode') === 'true';
    if (isDark) {
        document.body.classList.add('dark-mode');
    }
}

// 에러 핸들링
window.addEventListener('error', function(e) {
    console.error('JavaScript 오류:', e.error);
    logActivity('시스템 오류', `JavaScript 오류가 발생했습니다: ${e.message}`, 'error');
    showNotification('error', '시스템 오류', '예상치 못한 오류가 발생했습니다. 페이지를 새로고침해주세요.');
});

// API 오류 핸들링
window.addEventListener('unhandledrejection', function(e) {
    console.error('Promise 오류:', e.reason);
    logActivity('API 오류', `비동기 처리 오류: ${e.reason}`, 'error');
    
    if (e.reason && e.reason.message) {
        showNotification('error', 'API 오류', e.reason.message);
    }
});

// 성능 모니터링
function monitorPerformance() {
    const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
            if (entry.duration > 1000) {
                console.warn(`성능 경고: ${entry.name} took ${entry.duration}ms`);
                logActivity('성능 경고', `${entry.name} 작업이 ${Math.round(entry.duration)}ms 소요되었습니다.`, 'warning');
            }
        });
    });
    
    observer.observe({ entryTypes: ['measure', 'navigation'] });
}

// 브라우저 호환성 체크
function checkBrowserCompatibility() {
    const features = {
        'localStorage': typeof(Storage) !== 'undefined',
        'fetch': typeof(fetch) !== 'undefined',
        'Promise': typeof(Promise) !== 'undefined',
        'addEventListener': typeof(document.addEventListener) !== 'undefined'
    };
    
    const unsupported = Object.entries(features)
        .filter(([feature, supported]) => !supported)
        .map(([feature]) => feature);
    
    if (unsupported.length > 0) {
        showNotification('warning', '브라우저 호환성', 
            `일부 기능이 지원되지 않습니다: ${unsupported.join(', ')}. 최신 브라우저 사용을 권장합니다.`);
        logActivity('호환성 경고', `지원되지 않는 기능: ${unsupported.join(', ')}`, 'warning');
    }
}

// 데이터 백업/복원
function backupData() {
    const backupData = {
        topics: haircareTopics,
        automation: localStorage.getItem('hairgator_automation_settings'),
        stats: systemStats,
        timestamp: new Date().toISOString(),
        version: '1.0.0'
    };
    
    const dataStr = JSON.stringify(backupData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `hairgator_backup_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showNotification('success', '백업 완료', '데이터가 성공적으로 백업되었습니다.');
    logActivity('데이터 백업', '시스템 데이터를 백업했습니다.');
}

function restoreData(fileInput) {
    const file = fileInput.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            
            // 데이터 유효성 검사
            if (!backupData.topics || !backupData.timestamp) {
                throw new Error('유효하지 않은 백업 파일입니다.');
            }
            
            // 데이터 복원
            Object.assign(haircareTopics, backupData.topics);
            
            if (backupData.automation) {
                localStorage.setItem('hairgator_automation_settings', backupData.automation);
            }
            
            if (backupData.stats) {
                Object.assign(systemStats, backupData.stats);
                updateSystemStats();
            }
            
            // 화면 업데이트
            loadTopics();
            loadAutomationSettings();
            
            showNotification('success', '복원 완료', '데이터가 성공적으로 복원되었습니다.');
            logActivity('데이터 복원', `${backupData.timestamp} 백업 데이터를 복원했습니다.`);
            
        } catch (error) {
            showNotification('error', '복원 실패', `데이터 복원에 실패했습니다: ${error.message}`);
            logActivity('복원 실패', error.message, 'error');
        }
    };
    
    reader.readAsText(file);
}

// 시스템 정보 표시
function showSystemInfo() {
    const info = {
        version: '1.0.0',
        buildDate: '2024-01-15',
        features: [
            'AI 콘텐츠 생성 (Claude + OpenAI)',
            '헤어케어 전문 주제 관리',
            '실시간 품질 분석',
            '네이버 블로그 연동',
            '자동화 스케줄링',
            '시스템 모니터링'
        ],
        browser: navigator.userAgent,
        performance: performance.now()
    };
    
    console.table(info);
    showNotification('info', '시스템 정보', 
        `HAIRGATOR v${info.version} - ${info.features.length}개 주요 기능 탑재`);
}

// 개발자 도구 감지 (선택사항)
function detectDevTools() {
    let devtools = { open: false };
    
    setInterval(() => {
        if (console.profile) {
            console.profile();
            console.profileEnd();
            
            if (console.clear) {
                console.clear();
                if (console.log.toString().indexOf('native code') === -1) {
                    devtools.open = true;
                }
            }
        }
    }, 1000);
    
    return devtools;
}

// 초기화 완료 후 추가 설정
document.addEventListener('DOMContentLoaded', function() {
    // 추가 초기화 작업들
    setTimeout(() => {
        loadDarkModeSettings();
        checkBrowserCompatibility();
        monitorPerformance();
        
        // 환경 정보 로깅
        logActivity('시스템 정보', `브라우저: ${navigator.userAgent.split(' ').slice(-2).join(' ')}`);
        logActivity('시스템 정보', `화면 해상도: ${window.innerWidth}x${window.innerHeight}`);
        
        console.log('🦄 HAIRGATOR 시스템 완전 초기화 완료!');
        console.log('📊 시스템 정보를 보려면 showSystemInfo() 실행');
        console.log('🎯 키보드 단축키: Ctrl+S(임시저장), Ctrl+Enter(생성), Ctrl+P(미리보기)');
        
    }, 1000);
});

// 전역 함수들을 window 객체에 바인딩 (다른 스크립트에서 접근 가능)
window.HAIRGATOR = {
    generateContent,
    generateBulkContent,
    checkQuality,
    publishContent,
    previewContent,
    generateImage,
    showSystemInfo,
    backupData,
    restoreData,
    toggleDarkMode,
    version: '1.0.0'
};

// 콘솔 환영 메시지
console.log('%c🦄 HAIRGATOR 블로그 자동화 시스템', 'color: #667eea; font-size: 20px; font-weight: bold;');
console.log('%c✨ AI 기반 헤어케어 전문 콘텐츠 생성 시스템', 'color: #764ba2; font-size: 14px;');
console.log('%c🚀 시스템 버전: 1.0.0', 'color: #10b981; font-size: 12px;');
